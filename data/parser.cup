/*
 * BDParser.java
 *
 * Parser (syntactic analyzer for BrainDuck)
 *
 * KEEP IT SIMPLE STUPID
 * sometimes just: YOU AREN'T GONNA NEED IT
 *
 * Copyright (C) 2009-2010 Peter Jakubèo <pjakubco at gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

import java_cup.runtime.Symbol;
import emuLib8.plugins.compiler.IToken;
import brainc_brainduck.tree.*;
import emuLib8.plugins.compiler.ICompiler;

init with {: errorCount = 0; :}
parser code {:
    private BrainDuck compiler = null;
    public IToken lastToken;
    public int errorCount = 0;
    
    public BDParser(java_cup.runtime.Scanner s, BrainDuck compiler) {
        this(s);
        this.compiler = compiler;
    }
    	
    public void syntax_error(Symbol current) {
        errorCount++;
        report_error("Syntax error: ",current);
    }

    public void unrecovered_syntax_error(Symbol current) {
        errorCount++;
        report_error("Fatal syntax error: ", current);
        done_parsing();
    }

    public void report_error(String message, Symbol current) {
        String mes;

        IToken t = (IToken)current;
        mes = message + t.getErrorString() + " ('"+t.getText()+"')";

        compiler.fireMessage(t.getLine()+1,
                t.getColumn(), mes, 0, ICompiler.TYPE_ERROR);
    }
:}

terminal HALT,INC,DEC,INCV,DECV,PRINT,LOAD,LOOP,ENDL;
terminal EOL;
terminal String NUMBER;
terminal TCOMMENT;

non terminal Program Program;
non terminal Row Row;
non terminal Statement Statement;
non terminal Comment;
non terminal Integer NumberOpt;

start with Program;

Program ::= Row:row
            {:
                Program program = new Program();
                if (row != null) program.addRow(row);
                RESULT = program;
            :}
          | Program:program EOL Row:row
            {:
                if (row != null) program.addRow(row);
                RESULT = program;
            :};

Row ::= Statement:stmt Comment
        {: RESULT = new Row(stmt); :}
      | Comment
        {: RESULT = null; :};
         
Comment ::= TCOMMENT | ;

Statement ::= INC NumberOpt:num  {: RESULT = new Statement(Statement.INC, num); :}
            | DEC NumberOpt:num  {: RESULT = new Statement(Statement.DEC, num); :}
            | INCV NumberOpt:num {: RESULT = new Statement(Statement.INCV, num); :}
            | DECV NumberOpt:num {: RESULT = new Statement(Statement.DECV, num); :}
            | PRINT NumberOpt:num {: RESULT = new Statement(Statement.PRINT, num); :}
            | LOAD NumberOpt:num {: RESULT = new Statement(Statement.LOAD, num); :}
            | LOOP  {: RESULT = new Statement(Statement.LOOP, 0); :}
            | ENDL  {: RESULT = new Statement(Statement.ENDL, 0); :}
            | HALT  {: RESULT = new Statement(Statement.HALT, 0); :}
            ;

NumberOpt ::= NUMBER:num {: 

RESULT = Integer.parseInt((String)num)&0xFF;
                            
                         :}
            |            {: RESULT = 0xFF;   :}
            ;

