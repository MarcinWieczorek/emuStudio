/*
 * RAMParser.java
 *
 * Parser (syntactic analyzer for RAM)
 *
 * KEEP IT SIMPLE STUPID
 * sometimes just: YOU AREN'T GONNA NEED IT
 *
 * Copyright (C) 2009-2010 Peter Jakubèo <pjakubco at gmail.com>
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

import interfaces.IRAMInstruction;
import java_cup.runtime.Symbol;
import plugins.compiler.IToken;
import plugins.compiler.ICompiler;
import java.util.Vector;
import ramc_ram.tree.*;

init with {: errorCount = 0; :}
parser code {:
    private RAMCompiler ram = null;
    public IToken lastToken;
    public int errorCount = 0;
    
    public RAMParser(java_cup.runtime.Scanner s, RAMCompiler ram) {
        this(s);
        this.ram = ram;
    }
    	
    public void syntax_error(Symbol current) {
        errorCount++;
        report_error("Syntax error: ",current);
    }

    public void unrecovered_syntax_error(Symbol current) {
        errorCount++;
        report_error("Fatal syntax error: ", current);
        done_parsing();
    }

    public void report_error(String message, Symbol current) {
        String mes;

        IToken t = (IToken)current;
        mes = message + t.getErrorString() + " ('"+t.getText()+"')";
        
        ram.print_text(t.getLine()+1, t.getColumn(),mes, ICompiler.TYPE_ERROR);
    }
:}

terminal HALT,LOAD,STORE,READ,WRITE,ADD,SUB,MUL,DIV,JMP,JZ,JGTZ;
terminal EOL;
terminal DIRECT,INDIRECT;
terminal String NUMBER, IDENT, LABELL,STRING;
terminal TCOMMENT, INPUT;

non terminal Program Program;
non terminal Row Row;
non terminal RAMInstruction Statement;
non terminal Comment;
non terminal Integer Number;
non terminal Label LabelOpt;
non terminal Vector StringVector;

start with Program;

Program ::= Row:row
            {:
                Program program = new Program();
                if (row != null) program.addRow(row);
                RESULT = program;
            :}
          | Program:program EOL Row:row
            {:
                if (row != null) program.addRow(row);
                RESULT = program;
            :};

Row ::= LabelOpt:label Statement:stmt Comment
        {: RESULT = new Row(stmt, label); :}
      | LabelOpt:label Comment
        {: RESULT = (label==null)?null:new Row(label); :}
      | INPUT StringVector:vector 
        {: RESULT = new Row(vector); :};

StringVector ::= STRING:str
                 {: 
                     Vector<String> v = new Vector<String>();
                     v.add(str);
                     RESULT = v;
                 :}
               | StringVector:v STRING:str
                 {:
                     v.add(str);
                     RESULT = v;
                 :};

Comment ::= TCOMMENT | ;

LabelOpt ::= LABELL:label {: RESULT = new Label(label); :}
           |             {: RESULT = null; :}
           ;


Statement ::= READ Number:num {: RESULT = new RAMInstruction(IRAMInstruction.READ, (char)0, num); :}
            | READ INDIRECT Number:num {: RESULT = new RAMInstruction(IRAMInstruction.READ, '*', num); :}
            | WRITE DIRECT STRING:str {: RESULT = new RAMInstruction(IRAMInstruction.WRITE, '=', str); :}
            | WRITE Number:num {: RESULT = new RAMInstruction(IRAMInstruction.WRITE, (char)0, num); :}
            | WRITE INDIRECT Number:num {: RESULT = new RAMInstruction(IRAMInstruction.WRITE, '*', num); :}
            | LOAD DIRECT STRING:str {: RESULT = new RAMInstruction(IRAMInstruction.LOAD, '=', str); :}
            | LOAD Number:num {: RESULT = new RAMInstruction(IRAMInstruction.LOAD, (char)0, num); :}
            | LOAD INDIRECT Number:num {: RESULT = new RAMInstruction(IRAMInstruction.LOAD, '*', num); :}
            | STORE Number:num {: RESULT = new RAMInstruction(IRAMInstruction.STORE, (char)0, num); :}
            | STORE INDIRECT Number:num {: RESULT = new RAMInstruction(IRAMInstruction.STORE, '*', num); :}
            | ADD DIRECT STRING:str {: RESULT = new RAMInstruction(IRAMInstruction.ADD, '=', str); :}
            | ADD Number:num {: RESULT = new RAMInstruction(IRAMInstruction.ADD, (char)0, num); :}
            | ADD INDIRECT Number:num {: RESULT = new RAMInstruction(IRAMInstruction.ADD, '*', num); :}
            | SUB DIRECT STRING:str {: RESULT = new RAMInstruction(IRAMInstruction.SUB, '=', str); :}
            | SUB Number:num {: RESULT = new RAMInstruction(IRAMInstruction.SUB, (char)0, num); :}
            | SUB INDIRECT Number:num {: RESULT = new RAMInstruction(IRAMInstruction.SUB, '*', num); :}
            | MUL DIRECT STRING:str {: RESULT = new RAMInstruction(IRAMInstruction.MUL, '=', str); :}
            | MUL Number:num {: RESULT = new RAMInstruction(IRAMInstruction.MUL, (char)0, num); :}
            | MUL INDIRECT Number:num {: RESULT = new RAMInstruction(IRAMInstruction.MUL, '*', num); :}
            | DIV DIRECT STRING:str {: RESULT = new RAMInstruction(IRAMInstruction.DIV, '=', str); :}
            | DIV Number:num {: RESULT = new RAMInstruction(IRAMInstruction.DIV, (char)0, num); :}
            | DIV INDIRECT Number:num {: RESULT = new RAMInstruction(IRAMInstruction.DIV, '*', num); :}
            | JMP IDENT:label {: RESULT = new RAMInstruction(IRAMInstruction.JMP, label); :}
            | JZ IDENT:label {: RESULT = new RAMInstruction(IRAMInstruction.JZ, label); :}
            | JGTZ IDENT:label {: RESULT = new RAMInstruction(IRAMInstruction.JGTZ, label); :}
            | HALT  {: RESULT = new RAMInstruction(IRAMInstruction.HALT, (char)0,0); :}
            ;

Number ::= NUMBER:num {: RESULT = Integer.parseInt((String)num); :};

