= How to write a compiler for emuStudio
(c) Copyright 2006-2016, Peter Jakubčo
Version 0.39
:toc:
:numbered:

This tutorial will describe some basic knowledge about how to create a compiler to be used in emuStudio. The tutorial
does not aim to explain all the compiler theory, nor it is exhaustive. Fortunately, we have many tools which can
generate the hardest parts for us. All compilers in emuStudio use http://jflex.de/[JFlex] for generating the lexical
analyzer, and http://www2.cs.tum.edu/projects/cup/[Java cup] for generating parsers.

The tutorial focuses on how to use emuLib API in a compiler project so it can be used in emuStudio.

[[GETTING_STARTED]]
== Getting started

Before reading on, please read the "Introduction for writing virtual computers" document. It gives the information
needed for setting up the development environment and for basic understanding how the emuStudio/plug-ins lifecycle
work.

A compiler is just another plug-in, which means that it is enough to implement some API and that's it. The compiler
API can be found in `emulib.plugins.compiler` project package.

When implementing whole virtual computer, the compiler is usually an implementation of an assembler of the instruction
set used by CPU of the computer. In this tutorial, a simple assembler will be implemented for the world's very first
stored-program computer, https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine[SSEM], nicknamed
"Baby". It was a predecessor of Manchester Mark 1 which led to Ferranti Mark 1, the world's first commercially available
general-purpose computer.

In this tutorial, there won't be any deep description of the computer, rather the focus will be on the instruction set
itself, because it is very simple. The processor had only 7 instructions, each is 3-bit long. The instructions table
follows (modified from https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine#Programming[Wikipedia]):


[cols=">2m,<m,<5%m,<20%",frame="topbot",options="header,footer"]
|===================================================================
|Binary code |Modern mnemonic |Action            |Operation
|000         |JMP S           | S(L) -> CI      |Jump to the instruction at the address obtained from the specified memory
                                                  address `S(L)` (absolute unconditional jump)
|100         |JRP S           | CI + S(L) -> CI |Jump to the instruction at the program counter (`CI`) plus the
                                                  relative value obtained from the specified memory address `S(L)`
                                                  (relative unconditional jump)
|010         |LDN S           |-S(L) -> A       |Take the number from the specified memory address `S(L)`, negate it,
                                                  and load it into the accumulator
|110         |STO S           |A -> S(L)        |Store the number in the accumulator to the specified memory address `S(L)`
|001 or 101  |SUB S           |A - S(L) -> A    |Subtract the number at the specified memory address `S(L)` from the
                                                  value in accumulator, and store the result in the accumulator
|011         |CMP             |if A<0 then CI+1->CI |Skip next instruction if the accumulator contains a negative value
|111         |STP             |Stop              |
|===================================================================

NOTE: The bit-representation was kind of reversed. E.g., value `3` was represented by binary `110`, rather than `011`.

The instruction format is as follows:

[width="50%",cols=">2s,<m,<m,<m,<m,<m,<m,<m,<m,<m,<m,<m",frame="topbot",options="footer"]
.SSEM Instruction Format
|===================================================================
| Bit:  | 00  | 01 | 02 | 03 | 04 | ... | 13 | 14 | 15 | ... | 31
| Use:  | L   | L  | L  | L  | L  |  0  | F  | F  | F  | 0   | 0
| Value:| 2^0 |    |    |    |    |     |    |    |    |     | 2^31
|===================================================================

where bits `LLLLL` denote address (instruction operand), and bits `FFF` specify the instruction opcode.


== Language specification

Each compiler is just a program which translates a language into another. Language itself can have many translators
(compiler implementations). It is similar to when there is English language on the one hand, and there are people which
speak English on the other hand.

The computer programming languages must be specified in very formal way. The SSEM assembler specification can be
started with informal expressing, what it will know:

1. New-line character (LF, CR, or CRLF) will be required as a delimiter of instructions. Several successible empty
   new-line characters will be ignored.
2. Only modern representation of instructions will be supported by the assembler.
4. Raw number constants can be defined in separate lines (with `NUM xxx`).
5. Number constants (or instruction operands) can be defined in decimal or hexadecimal format (starting with `0x`).
6. Floating-point numbers will not be supported.
4. One-line comments will be supported, which start with double-slash (`//`). Everything after the `//` will be ignored.

For example, simple `5+3` addition can be implemented as follows:

    LDN 5 // load negative X into the accumulator
    SUB 3 // subtract Y from the value in the accumulator
    STO S // store the result at address S
    LDN S // load negative value at address S into the accumulator

The accumulator should now contain value `8`.

Numerical constants can look as follows:

    NUM 0x20
    NUM 1207943145

=== Lexical symbols (terminals)

The following table shows which categories of lexical symbols will exist:

[horizontal]
Reserved words:: `JMP`, `JRP`, `LDN`, `STO`, `SUB`, `CMP`, `STP`, `NUM`
Literals::
 - `number = (\-)?[0-9]+` or `(\-)?[0-9a-fA-F]`, range: `<0, 31)` (max. 2^5)
Comment::
 - `comment = //[^\r\n]*`
Separator::
 - `eol = \r|\n|\r\n`
 - `space = [\ \t]*` (will be ignored)

NOTE: Literals, comments and separator are described using regular expressions used in http://jflex.de/[JFlex], which
      is recommended for generating lexical analyzer.

These categories correspond to which compiler API supports. For all possible categories see class
https://github.com/vbmacher/emuLib/blob/branch-9_0/src/main/java/emulib/plugins/compiler/Token.java[Token.java].

[[GRAMMAR]]
=== Grammar for parser

The grammar presented here will be a deterministic context-free grammar, specifically LALR for bottom-up
parsing. It is because http://www2.cs.tum.edu/projects/cup/[Java cup] is used as parser generator, which produces only
LALR parsers. It has some implications to grammar design, when compared with LL grammars. The easiest way how to design
a LALR grammar is to put recursive non-terminals close to the end (right side), and terminals close to the beginning
(left side) of a grammar rule.

The complete grammar of presented SSEM assembler looks as follows:

[source,bison]
----
Program     : Statement Program | &Epsilon;
Statement   : Instruction Comment eol
  | Constant Comment eol
  | eol

Instruction : JMP number | JRP number | LDN number | STO number | SUB number | CMP | STP
Constant    : NUM number
Comment     : comment | &Epsilon;
----

== Preparing the environment

In order to start developing the compiler, create new Java project. Here, Maven will be used for dependencies management.
The plug-in will be implemented as another standard emuStudio plug-in, so it will inherit Maven plug-in dependencies
from the main POM file.

The project should be located at `emuStudio/plugins/compilers/as-ssem`, and should contain the following structure:

    src/
      main/
        java/
        resources/
    test/
      java/
    pom.xml

NOTE: Note the naming of the plug-in. It follows the naming convention as described in the
      "Introduction for writing virtual computers" guide.

The POM file of the project might look as follows:

[source,xml]
.`pom.xml`
----
include::../../../plugins/compilers/as-ssem/pom.xml[]
----

And let's start with the first Java class, the main plug-in class. Let's put it to package
`net.sf.emustudio.ssem.assembler`, and call it `CompilerImpl`.

== Implementing basic stuff

Go to the `CompilerImpl` class source. Extend the class from `emulib.plugins.compiler.AbstractCompiler` class.
The class extends from `Compiler` interface and implements the most common methods, usable by all compilers.

It is also necessary to annotate the class with `emulib.annotations.PluginType` annotation, and pass the
one argument of the constructor to the super class. The code snippet looks as follows:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/CompilerImpl.java`
----
package net.sf.emustudio.ssem.assembler;

import emulib.annotations.PLUGIN_TYPE;
import emulib.annotations.PluginType;
import emulib.plugins.compiler.AbstractCompiler;
import emulib.runtime.ContextPool;

@PluginType(
        type = PLUGIN_TYPE.COMPILER,
        title = "SSEM Assembler",
        copyright = "\u00A9 Copyright 2016, YourName",
        description = "Assembler of SSEM processor language"
)
public class CompilerImpl extends AbstractCompiler {

    public CompilerImpl(Long pluginID, ContextPool contextPool) {
        super(pluginID);
    }

    // ... other methods ...
}
----

NOTE: The constructor presented here is mandatory. This is one of the behavioral contracts, emuStudio expects
      that a plug-in will have a constructor with two arguments: pluginID (assigned by emuStudio), and a context
      pool, which will be described later, in another type of plug-ins.

== Implement lexical analyzer

Now the time become to write the lexical analyzer. As it was mentioned before, http://jflex.de/[JFlex] will be
used for generating the Java code from `jflex` specification file. See the link of the JFlex for more information.

The usual place to put the specfile is at `src/main/jflex`. The file will be named `ssem.jflex` The file will be
automatically parsed, and the lexer generated using
http://jflex.sourceforge.net/maven-jflex-plugin/generate-mojo.html[JFlex Maven plugin] (see the POM file above).

Before the implementation of the specfile, we need to implement `TokenImpl` class. This class holds the basic
information about the parsed token, and it extends `java_cup.runtime.Symbol` class, and implements
`emulib.plugins.compiler.Token` and `Symbols` interface. We will talk about `Symbols` in parser section.

The content of the `net.sf.emustudio.ssem.assembler.TokenImpl` class is:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/TokenImpl.java`
----
include::../../../plugins/compilers/as-ssem/src/main/java/net/sf/emustudio/ssem/assembler/TokenImpl.java[]
----

Now, we can define the lexical analyzer:

[source,flex]
.`src/main/jflex/ssem.jflex`
----
include::../../../plugins/compilers/as-ssem/src/main/jflex/ssem.jflex[]
----

Token in emuStudio is very important also for syntax highlighting in the editor. For parsing, each token must have
its unique identification number (token ID), such as `JMP`, `SEPARATOR_EOL`, `NUMBER`, etc. from the above file.
However, for doing syntax highlighting, it wouldn't be that beneficial if the color of a token was based on its
ID, because for example each instruction would have different color. Rather, in emuLib there exist token categories,
which are used when considering token color. Token categories are defined in the class `emulib.plugins.compiler.Token`.

=== Test it!

It is now very required practice to write unit tests, this is especially useful when very concrete specification
is available. Here are some code snippets, which can be implemented right away for testing the lexer:

[source,java]
.`src/test/java/net/sf/emustudio/ssem/assembler/LexerTest.java`
----
include::../../../plugins/compilers/as-ssem/src/test/java/net/sf/emustudio/ssem/assembler/LexerTest.java[]
----

Lexer and parser are very interconnected in this case, because Java Cup defines symbol table, which is used by
`TokenImpl` class. It does not yet exist when we have only lexer, so I guess the best way is to continue with parser
and then make it work together.

== Implement parser

The code won't compile so far. The reason is that there are not defined symbols used in the lexer (e.g. `JMP`,
`SEPARATOR_EOL`, etc.). However, the symbols will be generated when the parser (more formally, syntactic analyzer)
will be implemented. Let's do it.

As was mentioned before, the parser generator will be used, called http://www2.cs.tum.edu/projects/cup/[Java cup].
I have prepared Maven plug-in in order to be usable from Maven. This is called `cup-maven-plugin`, and you can see
the definition in the POM file.

There are more options of how to create the parser. The provided URL of Java cup contains lots of documentation. In
this tutorial, an abstract syntax tree will be implemented and created by the parser. Abstract Syntax Tree (or AST) is
a representation of the parsed program source code in a form plausible for further compilation process. It is different
from Parse Syntax Tree, which represents the tree of grammar derivations for the program.

For example, expression "2+2" can be represented using the following AST:

[graphviz]
---------------------------------------------------------------------
digraph ast {
  one [label="2"];
  two [label="2"];

  "+" -> one;
  "+" -> two;
}
---------------------------------------------------------------------

where each node of that tree, regardless if it is leaf or not, is an class in Java, like this example:

[source,java]
----
interface AST {
  int evaluate();
}

class PlusOperator implements AST {
  private final AST left;
  private final AST right;

  public PlusOperator(AST left, AST right) {
    this.left = left;
    this.right = right;
  }

  @Override
  int evaluate() {
    return left.evaluate() + right.evaluate();
  }
}

class Value implements AST {
  private final int value;

  public Value(int value) {
    this.value = value;
  }

  @Override
  public int evaluate() {
    return value;
  }
}
----

And these classes are assembled by the parser, like this imaginary example:

[source,java]
----
AST program = parser.parse("2+2"); // The parser returns: new PlusOperator(new Value(2), new Value(2))
System.out.println(program.evaluate()); // prints "4"
----

This is the basic idea of how parsing works. Now, it is needed to create:

1. Abstract syntax tree classes for our SSEM assembler program
2. Write parser definition file itself, which will contain the grammar and will build the AST for the program

=== Grammar file

Let's start with the parser definition file (or parser specfile). It will be put to `src/main/cup/parser.cup`.
The content is as follows:

[source]
.`src/main/cup/parser.cup`
----
include::../../../plugins/compilers/as-ssem/src/main/cup/parser.cup[]
----

More-less it is possible to recognize grammar which was defined in section <<GRAMMAR, Grammar for parser>>. The right
side, code snippets wrapped between `{:` and `:}` is Java code which will be executed when particular rule of the
grammar applies. There exist a special variable `RESULT`, which should return some Java object of type which the
non-terminal defines footnote:[For example, `non terminal Instruction Statement;` in the gramamr above defines a
non-terminal `Statement`, which should return an instance of `Instruction` class. The class `Instruction` must be
implemented manually - it is part of AST; there are no special requirements for the implementation.].
I suggest to read Java Cup documentation for more information, especially about the `error` symbol.

=== Abstract Syntax Tree

Classes which non-terminals use are in fact parts of abstract syntax tree of the compiler, namely only the following:

- `Program`
- `Instruction`
- `Constant`

All the classes are part of AST. We already know that, but it is not useful information and we do not program this
explicitly if we don't need something which all AST nodes have in common. For now, it's not important to do it.
For now, these will be just normal classes, which will be put into package `net.sf.emustudio.ssem.assembler.tree`.

The initial implementation of the classes follows:

[source, java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/Program.java`
----
package net.sf.emustudio.ssem.assembler.tree;

import java.util.ArrayList;
import java.util.List;

public class Program {
    private final List<Instruction> instructions = new ArrayList<>();

    public void statement(Instruction instruction) {
        instructions.add(instruction);
    }

}
----

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/Instruction.java`
----
package net.sf.emustudio.ssem.assembler.tree;

import java.util.Optional;

public class Instruction {
    private final static byte JMP = 0; // 000
    private final static byte JRP = 4; // 100
    private final static byte LDN = 2; // 010
    private final static byte STO = 6; // 110
    private final static byte SUB = 1; // 001
    private final static byte CMP = 3; // 011
    private final static byte STP = 7; // 111

    private final int opcode;
    private final Optional<Byte> operand;

    private Instruction(int opcode, byte operand) {
        this.operand = Optional.of(operand);
        this.opcode = opcode;
    }

    private Instruction(int opcode) {
        this.operand = Optional.empty();
        this.opcode = opcode;
    }

    public int getOpcode() {
        return opcode;
    }

    public Optional<Byte> getOperand() {
        return operand;
    }

    public static Instruction jmp(byte address) {
        return new Instruction(JMP, address);
    }

    public static Instruction jrp(byte address) {
        return new Instruction(JRP, address);
    }

    public static Instruction ldn(byte address) {
        return new Instruction(LDN, address);
    }

    public static Instruction sto(byte address) {
        return new Instruction(STO, address);
    }

    public static Instruction sub(byte address) {
        return new Instruction(SUB, address);
    }

    public static Instruction cmp() {
        return new Instruction(CMP);
    }

    public static Instruction stp() {
        return new Instruction(STP);
    }
}
----

Pay attention to the `Instruction` class. The constructor is private, so there's just impossible to create some
invalid `Instruction` object. The only possible way how to define it is using static factory methods, which represents
the machine instructions. These are called from the parser, please check the parser specfile in the section above.

And finally the `Constant.java` class:

[source,java]
----
public class Constant {
    private final int number;

    public Constant(int number) {
        this.number = number;
    }

    public int getNumber() {
        return number;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Constant constant = (Constant) o;

        return number == constant.number;
    }

    @Override
    public int hashCode() {
        return number;
    }
}
----

Comparing `Constant` instances is based on comparing the numbers they represent.

=== Test it!

Again, it is now very required practice to write unit tests for parser. Here are some code snippets, which can be
implemented right away for testing the parser:

[source,java]
.`src/test/java/net/sf/emustudio/ssem/assembler/ParserTest.java`
----
include::../../../plugins/compilers/as-ssem/src/test/java/net/sf/emustudio/ssem/assembler/ParserTest.java[]
----

If you noticed, the tests are based on comparing `Instruction` and `Constant` instances with JUnit's `assertEquals()`
method. This is possible only if we override `equals()` and `hashCode()` methods in the classes, since they are used
directly by Java when it is comparing the instances:

[source,java]
----
public class Instruction {

    ...

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Instruction that = (Instruction) o;
        return opcode == that.opcode && operand.equals(that.operand);
    }

    @Override
    public int hashCode() {
        int result = opcode;
        result = 31 * result + operand.hashCode();
        return result;
    }

    ...
}
----

The comparison is based on comparing the opcode and operand of the instruction. The same thing must be done for
`Constant` class:


----
public class Constant {

    ...

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Constant constant = (Constant) o;

        return number == constant.number;
    }

    @Override
    public int hashCode() {
        return number;
    }

    ...
}
----


== Generating code

It is sometimes very useful to separate algorithm and data representation class. In Java, data representation objects
are often called POJOs, or in database environment DAOs (data access objects). We can use this pattern also in our tree
of parsed program. The tree should contain just information about *what* the program contains. But we can treat the
program in many ways. For example, we can print it, we can check it for semantic errors, we can use it for generating
binary code from it, etc.

Specification of *how* to treat the program should be therefore put separately from the AST itself, in different classes.
There is a very useful design pattern from OOP called https://en.wikipedia.org/wiki/Visitor_pattern[Visitor pattern],
which is exactly what we need here. Within this pattern, our program-treating-algorithm (e.g. a code generator) we will
call a visitor, because of the way how it will work. The basic principle is that the visitor will traverse the program
in a bit tricky way, and when it encounters (visits) a node from AST, it will do something with it (e.g. generate a
code).

So, at first, it is necessary to define the vistor itself. Which AST nodes are useful for traversing? I think that
only `Instruction` node is worth of something. So the visitor interface will look as follows:

[source, java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/ASTvisitor.java`
----
include::../../../plugins/compilers/as-ssem/src/main/java/net/sf/emustudio/ssem/assembler/tree/ASTvisitor.java[]
----

Now, we can implement a code generator, which will be a visitor. For each encountered instruction it will generate
the binary code. But wait - we need the code for traversing the AST. And here's the trick. The AST itself will know
how to traverse it. This is probably the most tricky part about the Visitor pattern.

In order to define traversal of AST generally, we now need a common interface - `ASTnode` interface, which will define
method for traversing:

[source, java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/ASTnode.java`
----
include::../../../plugins/compilers/as-ssem/src/main/java/net/sf/emustudio/ssem/assembler/tree/ASTnode.java[]
----

This interface will be implemented by AST nodes. The weird `accept()` method implements the traversing. So it in fact
"accepts" a visitor and lets him "visit" current node in a way the visitor defines, taking into account also possible
children nodes. So, let's modify our AST nodes:


[source, java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/Program.java`
----
include::../../../plugins/compilers/as-ssem/src/main/java/net/sf/emustudio/ssem/assembler/tree/Program.java[]
----


[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/Instruction.java`
----
public class Instruction implements ASTnode {

    ....

    @Override
    public void accept(ASTvisitor visitor) throws Exception {
         visitor.visit(this);
    }
}
----

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/tree/Constant.java`
----
public class Constant implements ASTnode {

    ....

    @Override
    public void accept(ASTvisitor visitor) throws Exception {
         visitor.visit(this);
    }
}
----

Simple enough, right? You can notice the "reverse" behavior of the visitor pattern, as we are traversing the tree
of the parsed program and how Java calls the correct method on the `ASTVisitor` for the specific type without need to
explicit retype or using weird `switch` clause.

Now back to the code generation. It is better if I/O classes work with I/O abstractions (streams, channels, etc.) rather
than specific objects, e.g. files. This code generator will be implemented in a similar fashion. The code is as follows:


[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/CodeGenerator.java`
----
include::../../../plugins/compilers/as-ssem/src/main/java/net/sf/emustudio/ssem/assembler/CodeGenerator.java[]
----

What it does is basically creating a 4-byte SSEM instruction, its binary format. As was mentioned before, SSEM uses
"reversed" bits for number representations. This is the reason why the address number is twisted. Before that, it is
however necessary to check the address boundary, which is 2^5 (maximum). The rest should be clear, we're making
instruction with format specified in section <<GETTING_STARTED,Getting started>>.

=== Test it!

As being our practice, we must test it.

[source,java]
.`src/test/java/net/sf/emustudio/ssem/assembler/CodeGeneratorTest.java`
----
include::../../../plugins/compilers/as-ssem/src/test/java/net/sf/emustudio/ssem/assembler/CodeGeneratorTest.java[]
----

== Finalizing, implementing the rest

We're almost done now! What is missing so far is to finish implementation of the main `CompilerImpl` class.
Let's do it.

The most interesting is the `compile()` method. So let's begin with it first.

[source,java]
.`src/main/java/net/sf/emustudio/ssem/assembler/CompilerImpl.java`
----
public class CompilerImpl extends AbstractCompiler {

    ....

    @Override
    public boolean compile(String inputFileName, String outputFileName) {

        notifyCompileStart();

        int errorCode = 0;
        try (Reader reader = new FileReader(inputFileName)) {
            try (CodeGenerator codeGenerator = new CodeGenerator(new FileOutputStream(outputFileName))) {
                LexerImpl lexer = new LexerImpl(reader);
                ParserImpl parser = new ParserImpl(lexer, new ComplexSymbolFactory(), this);

                Program program = (Program) parser.parse().value;
                if (program == null) {
                    throw new Exception("Unexpected end of file");
                }
                if (parser.hasSyntaxErrors()) {
                    throw new Exception("One or more errors has been found, cannot continue.");
                }

                program.accept(codeGenerator);
                notifyInfo("Compile was successful. Output: " + outputFileName);
            }
        } catch (Exception e) {
            errorCode = 1;
            return false;
        } finally {
            notifyCompileFinish(errorCode);
        }

        return true;
    }

    ....
}
----

As input, we have full path to the input file, and to the output file. It is good to use some Java 7 try-with-resources
statement for opening the files. The same approach can be used for the code generator, because the class implements
`AutoCloseable` interface.

We want to notify emuStudio about compilation progress, as we have already done in the parser, when dealing with
parsing errors. For this purpose, `emulib.plugins.compiler.AbstractCompiler` class offers several methods:

- `notifyCompileStart()`, which will inform emuStudio that the compilation has started,
- `notifyCompileFinish(errorCode)` will inform emuStudio that the compilation has finished, with given error code. footnote:[The
  error code should be defined by you, developer, if you want. It is a convention used also in other compilers that
  specific error has assigned a unique number. In our compiler, we do not use it.]
- `notifyOnMessage()` - notifies emuStudio about some general message, it can be either error, info, warning.
- `notifyWarning()` - compiler warning
- `notifyError()` - compilation error
- `notifyInfo()` - informational message

=== Loading compiler program into memory

The very last part I leave as an excercise. In provided source codes this functionality is ofcourse implemented,
but at the end - it is up to you if you'll use my solution or not.
