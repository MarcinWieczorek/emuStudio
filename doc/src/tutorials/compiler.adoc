= How to write a compiler for emuStudio
(c) Copyright 2007-2015, Peter Jakubƒço
Version 0.39
:toc:
:numbered:

This tutorial will describe some basic knowledge about how to create a compiler to be used in emuStudio. The tutorial
does not aim to explain all the compiler theory, nor it is exhaustive. Fortunately, we have many tools which can
generate the hardest parts for us. All compilers in emuStudio use http://jflex.de/[JFlex] for generating the lexical
analyzer, and http://www2.cs.tum.edu/projects/cup/[Java cup] for generating parsers.

The tutorial focuses on how to use emuLib API in a compiler project so it can be used in emuStudio.

== Getting started

Before reading on, please read the "Introduction for writing virtual computers" document. It gives the information
needed for setting up the development environment and for basic understanding how the emuStudio/plug-ins lifecycle
work.

A compiler is just another plug-in, which means that it is enough to implement some API and that's it. The compiler
API can be found in `emulib.plugins.compiler` project package.

When implementing whole virtual computer, the compiler is usually an implementation of an assembler of the instruction
set used by CPU of the computer. In this tutorial, a simple assembler will be implemented for the world's very first
stored-program computer, https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine[SSEM], nicknamed
"Baby". It was a predecessor of Manchester Mark 1 which led to Ferranti Mark 1, the world's first commercially available
general-purpose computer.

In this tutorial, there won't be any deep description of the computer, rather the focus will be on the instruction set
itself, because it is very simple. The processor had only 7 instructions, each is 3-bit long. The instructions table
follows (taken from https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine#Programming[Wikipedia]):

|===
|Binary code |Original notation |Modern mnemonic |Operation

|`000`
|`S, Cl`
|`JMP S`
|Jump to the instruction at the address obtained from the specified memory address `S[a]` (absolute unconditional jump)

|`100`
|`Add S, Cl`
|`JRP S`
|Jump to the instruction at the program counter plus (`+`) the relative value obtained from the specified memory
 address `S[a]` (relative unconditional jump)

|`010`
|`-S, C`
|`LDN S`
|Take the number from the specified memory address `S`, negate it, and load it into the accumulator

|`110`
|`c, S`
|`STO S`
|Store the number in the accumulator to the specified memory address `S`

|`001` or `101`[b]
|`SUB S`
|`SUB S`
|Subtract the number at the specified memory address `S` from the value in accumulator, and store the result
 in the accumulator

|`011`
|`Test`
|`CMP`
|Skip next instruction if the accumulator contains a negative value

|`111`
|`Stop`
|`STP`
|Stop

|===


NOTE: The bit-representation was kind of reversed. E.g., value `3` was represented by binary `110`, rather than `011`.

== Language specification

Each compiler is just a program which translates a language into another. Language itself can have many translators
(compiler implementations). It is similar to when there is English language on the one hand, and there are people which
speak English on the other hand.

The computer programming languages must be specified in very formal way. The modern foundations of formal grammars
was put by https://en.wikipedia.org/wiki/Syntactic_Structures[Noam Chomsky].

The SSEM assembler specification can be started with informal expressing, what it will know:

1. New-line character (LF, CR, or CRLF) will be required as a delimiter of instructions. Several successibe empty new-line
   characters will be ignored.
2. Only modern representation of instructions will be supported by the assembler.
3. Only decimal literals (numbers) will be supported as instruction operands. Negation will be supported. Floating-point
   numbers are not supported.
4. One-line comments will be supported, which start with double-slash (`//`). Everything after the `//` will be ignored.

For example, simple `5+3` addition can be implemented as follows:

    LDN 5 // load negative X into the accumulator
    SUB 3 // subtract Y from the value in the accumulator
    STO S // store the result at address S
    LDN S // load negative value at address S into the accumulator

The accumulator should now contain value `8`.

=== Lexical symbols (terminals)

The following table shows which categories of lexical symbols will exist:

[horizontal]
Reserved words:: `JMP`, `JRP`, `LDN`, `STO`, `SUB`, `CMP`, `STP`
Literals::
 - `number = (\-)?[0-9]+`
Comment::
 - `comment = //[^\r\n]*`
Separator::
 - `eol = \r|\n|\r\n`
 - `space = [\ \t]*` (will be ignored)

NOTE: Literals, comments and separator are described using regular expressions used in http://jflex.de/[JFlex], which
      is recommended for generating lexical analyzer.

These categories correspond to which compiler API supports. For all possible categories see class
https://github.com/vbmacher/emuLib/blob/branch-9_0/src/main/java/emulib/plugins/compiler/Token.java[Token.java].


=== Grammar for parser

The grammar presented here will be a https://en.wikipedia.org/wiki/LR_parser[LR(1)] grammar, for bottom-up parsing.
It is because http://www2.cs.tum.edu/projects/cup/[Java cup] is used as parser generator, which utilizes only LR
grammars. It has some implications to grammar design, when compared with LL grammars. The easiest way how to design
a grammar is to put recursive non-terminals close to beginning, and terminals close to the end of a grammar rule.

The complete grammar of presented SSEM assembler looks as follows:

[source,bison]
----
    Program     : Program Statement eol | eol
    Statement   : Instruction | Instruction Comment | Comment

    Instruction : JMP number | JRP number | LDN number | STO number | SUB number | CMP | STP
    Comment     : comment
----

== Preparing the environment

In order to start developing the compiler, create new Java project. Here, Maven will be used for dependencies management.
The plug-in will be implemented as another standard emuStudio plug-in, so it will inherit Maven plug-in dependencies
from the main POM file.

The project should be located at `emuStudio/plugins/compilers/as-ssem`, and should contain the following structure:

    src/
      main/
        java/
        resources/
    test/
      java/
    pom.xml

NOTE: Note the naming of the plug-in. It follows the naming convention as described in the
      "Introduction for writing virtual computers" guide.

The POM file of the project might look as follows:

[source]
----
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <parent>
    <artifactId>emustudio-parent</artifactId>
    <groupId>net.sf.emustudio</groupId>
    <version>0.39-SNAPSHOT</version>
    <relativePath>../../../pom.xml</relativePath>
  </parent>
  <modelVersion>4.0.0</modelVersion>

  <artifactId>as-ssem</artifactId>

  <name>SSEM assembler</name>
  <description>Assembler of SSEM processor language</description>

  <build>
    <finalName>as-ssem</finalName>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-jar-plugin</artifactId>
        <configuration>
          <archive>
            <manifest>
              <addClasspath>false</addClasspath>
              <mainClass>net.sf.emustudio.ssem.assembler.CompilerImpl</mainClass>
              <addDefaultImplementationEntries>true</addDefaultImplementationEntries>
              <addDefaultSpecificationEntries>true</addDefaultSpecificationEntries>
            </manifest>
            <manifestEntries>
              <Class-Path>lib/java-cup-runtime-11b.jar</Class-Path>
            </manifestEntries>
          </archive>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
      </plugin>
      <plugin>
        <groupId>de.jflex</groupId>
        <artifactId>jflex-maven-plugin</artifactId>
        <executions>
          <execution>
            <goals>
              <goal>generate</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
      <plugin>
        <groupId>com.github.vbmacher</groupId>
        <artifactId>cup-maven-plugin</artifactId>
        <executions>
          <execution>
            <goals>
              <goal>generate</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <className>ParserImpl</className>
          <symbolsName>Symbols</symbolsName>
        </configuration>
      </plugin>
    </plugins>
  </build>

  <dependencies>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
    </dependency>
    <dependency>
      <groupId>net.sf.emustudio</groupId>
      <artifactId>emuLib</artifactId>
    </dependency>
    <dependency>
      <groupId>com.github.vbmacher</groupId>
      <artifactId>java-cup-runtime</artifactId>
    </dependency>
  </dependencies>
</project>
----

And let's start with the first Java class, the main plug-in class. Let's put it to package
`net.sf.emustudio.ssem.assembler`, and call it `CompilerImpl`.

== Implementing basic stuff

Go to the `CompilerImpl` class source. Extend the class from `emulib.plugins.compiler.AbstractCompiler` class.
The class extends from `Compiler` interface and implements the most common methods, usable by all compilers.

It is also necessary to annotate the class with `emulib.annotations.PluginType` annotation, and pass the
one argument of the constructor to the super class. The code snippet looks as follows:

[source,java]
----
@PluginType(
        type = PLUGIN_TYPE.COMPILER,
        title = "SSEM Assembler",
        copyright = "\u00A9 Copyright 2016, YourName",
        description = "Assembler of SSEM processor language"
)
public class CompilerImpl extends AbstractCompiler {

    public CompilerImpl(Long pluginID) {
        super(pluginID);
    }

    // ... other methods ...
}
----

== Implement lexical analyzer

Now the time become to write the lexical analyzer. As it was mentioned before, http://jflex.de/[JFlex] will be
used for generating the Java code from `jflex` specification file. See the link of the JFlex for more information.

The usual place to put the specfile is at `src/main/jflex`. The file will be named `ssem.jflex` The file will be
automatically parsed, and the lexer generated using
http://jflex.sourceforge.net/maven-jflex-plugin/generate-mojo.html[JFlex Maven plugin] (see the POM file above).

Before the implementation of the specfile, we need to implement `TokenImpl` class. This class holds the basic
information about the parsed token, and it extends `java_cup.runtime.Symbol` class, and implements
`emulib.plugins.compiler.Token` interface. This is quite complicated, and it might be simplified in future versions to
use just plan `java_cup.runtime.Symbol` class.

The content of the `net.sf.emustudio.ssem.assembler.TokenImpl` class is:

[source,java]
----
package net.sf.emustudio.ssem.assembler;

import emulib.plugins.compiler.Token;
import java_cup.runtime.Symbol;

public class TokenImpl extends Symbol implements Token {
    private final String text;
    private final int category;
    private final int cchar;

    public TokenImpl(int id, int category, String text, int line, int column, int cchar) {
        super(id, line, column);
        this.text = text;
        this.category = category;
        this.cchar = cchar;
    }

    public TokenImpl(int id, int category, String text, int line, int column, int cchar, Object value) {
        super(id, line, column, value);
        this.text = text;
        this.category = category;
        this.cchar = cchar;
    }

    @Override
    public int getID() {
        return super.sym;
    }

    @Override
    public int getType() {
        return super.sym;
    }

    @Override
    public int getLine() {
        return super.left;
    }

    @Override
    public int getColumn() {
        return super.right;
    }

    @Override
    public int getOffset() {
        return cchar;
    }

    @Override
    public int getLength() {
        return cchar + text.length();
    }

    @Override
    public String getErrorString() {
        return "Unknown token";
    }

    @Override
    public String getText() {
        return text;
    }

    @Override
    public boolean isInitialLexicalState() {
        return true;
    }
}
----

Now, we can define the lexical analyzer in `src/main/jflex/ssem.jflex`:

[source,flex]
----
    package net.sf.emustudio.ssem.assembler;

    import emulib.plugins.compiler.LexicalAnalyzer;
    import emulib.plugins.compiler.Token;
    import java.io.IOException;
    import java.io.Reader;

    %%

    /* options */
    %class LexerImpl
    %cup
    %public
    %implements LexicalAnalyzer, Symbols
    %line
    %column
    %char
    %caseless
    %unicode
    %type TokenImpl

    %{
        @Override
        public Token getSymbol() throws IOException {
            return next_token();
        }

        @Override
        public void reset(Reader in, int yyline, int yychar, int yycolumn) {
            yyreset(in);
            this.yyline = yyline;
            this.yychar = yychar;
            this.yycolumn = yycolumn;
        }

        @Override
        public void reset() {
            this.yyline = 0;
            this.yychar = 0;
            this.yycolumn = 0;
        }

        private TokenImpl token(int type, int category) {
            return new TokenImpl(type, category, yytext(), yyline, yycolumn, yychar);
        }

        private TokenImpl token(int type, int category, Object value) {
            return new TokenImpl(type, category, yytext(), yyline, yycolumn, yychar, value);
        }
    %}

    comment = "//"[^\r\n]*
    eol = \r|\n|\r\n
    space = [ \t\f]+
    number = \-?[0-9]+

    %%

    /* reserved words */
    "jmp" {
        return token(JMP, Token.RESERVED);
    }
    "jrp" {
        return token(JRP, Token.RESERVED);
    }
    "ldn" {
        return token(LDN, Token.RESERVED);
    }
    "sto" {
        return token(STO, Token.RESERVED);
    }
    "sub" {
        return token(SUB, Token.RESERVED);
    }
    "cmp" {
        return token(CMP, Token.RESERVED);
    }
    "stp" {
        return token(STP, Token.RESERVED);
    }

    /* separators */
    {eol} {
        return token(SEPARATOR_EOL, Token.SEPARATOR);
    }
    {space} { /* ignore white spaces */ }

    /* comment */
    {comment} {
        return token(TCOMMENT, Token.COMMENT);
    }

    /* literals */
    {number} {
        try {
            int num = Integer.parseInt(yytext(), 10);
            return token(NUMBER, Token.LITERAL, num);
        } catch (NumberFormatException e) {
            return token(NUMBER, Token.ERROR, e.getMessage());
        }
    }

    /* error fallback */
    [^] {
        return token(ERROR_UNKNOWN_TOKEN, Token.ERROR);
    }
----

== Implement parser

The code won't compile so far. The reason is that there are not defined symbols used in the lexer (e.g. `JMP`,
`SEPARATOR_EOL`, etc.). However, the symbols will be generated when the parser (more formally, syntactic analyzer)
will be implemented. Let's do it.

As was mentioned before, the parser generator will be used, called http://www2.cs.tum.edu/projects/cup/[Java cup].
I have prepared Maven plug-in in order to be usable from Maven. This is called `cup-maven-plugin`, and you can see
the definition in the POM file.

There are more options of how to create the parser. The provided URL of Java cup contains lots of documentation. In
this tutorial, an abstract syntax tree will be implemented and created by the parser. Abstract Syntax Tree (or AST) is
a representation of the parsed program source code. For example, expression "2+2" can be represented using the following
AST:

[graphviz]
---------------------------------------------------------------------
digraph ast {
  one [label="2"];
  two [label="2"];

  "+" -> one;
  "+" -> two;
}
---------------------------------------------------------------------

where each node of that tree, regardless if it is leaf or not, is an class in Java, like this example:

[source,java]
----
interface AST {
  int evaluate();
}

class PlusOperator implements AST {
  private final AST left;
  private final AST right;

  public PlusOperator(AST left, AST right) {
    this.left = left;
    this.right = right;
  }

  @Override
  int evaluate() {
    return left.evaluate() + right.evaluate();
  }
}

class Value implements AST {
  private final int value;

  public Value(int value) {
    this.value = value;
  }

  @Override
  public int evaluate() {
    return value;
  }
}
----

And these classes are assembled by the parser, like this imaginary example:

[source,java]
----
AST program = parser.parse("2+2"); // The parser returns: new PlusOperator(new Value(2), new Value(2))
System.out.println(program.evaluate()); // prints "4"
----

This is the basic ide of how it works. So now we need to create:

1. Abstract syntax tree classes for our SSEM assembler program
2. Write parser definition file itself, which will contain the grammar and will build the AST for the program

Let's start with the parser definition file (or parser specfile). It will be put to `src/main/cup/ssem.cup`.
The content is as follows:


