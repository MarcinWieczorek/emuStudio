= How to write a CPU for emuStudio
(c) Copyright 2007-2016, Peter Jakubƒço
Version 0.39
:toc:
:numbered:

This tutorial will describe some basic knowledge about how to create a CPU to be used in emuStudio. The tutorial
does not aim to explain emulation techniques in much detail, nor it is exhaustive. This is left for the programmer.
The tutorial focuses on how to use emuLib API in a CPU project so it can be used in emuStudio.

[[GETTING_STARTED]]
== Getting started

Before reading on, please read the "Introduction for writing virtual computers" document. It gives the information
needed for setting up the development environment and for basic understanding how the emuStudio/plug-ins lifecycle
work.

A CPU is just another plug-in, which means that it is enough to implement some API and that's it. The CPU
API can be found in `emulib.plugins.cpu` project package.

CPU is supposed to be the core of the emulator in the similar way as the real CPU is core to the computer.
The term "emulation technique" is usually used when we talk about CPU emulation. This tutorial will focus on
the interpretation technique, because it is the most basic one and simple one. Also, the advanced techniques, like
dynamic translation (which translates target code snippets into native host code in the runtime) is probably not
feasible to do in Java.

NOTE: More information about emulation techniques can be found for example at
      http://www.xsim.com/papers/Bario.2001.emubook.pdf[this link].

In this tutorial, a simple CPU will be implemented for the world's very first stored-program computer,
https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine[SSEM], nicknamed
"Baby". It was a predecessor of Manchester Mark 1 which led to Ferranti Mark 1, the world's first commercially available
general-purpose computer.

== Preparing the environment

Since emuStudio uses Maven for project organization and dependency management, this plug-in will be developed also
in this manner. So lets' start with basic
https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html[Maven project structure], you can use
`mvn archetype:generate` command to be faster.

The project should be located at `emuStudio/plugins/cpu/ssem-cpu`, and should contain the following structure:

    src/
      main/
        java/
        resources/
    test/
      java/
    pom.xml


The content of `pom.xml` is as follows:

[source,xml]
.`pom.xml`
----
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <parent>
    <groupId>net.sf.emustudio</groupId>
    <artifactId>emustudio-parent</artifactId>
    <version>0.39-SNAPSHOT</version>
    <relativePath>../../..</relativePath>
  </parent>

  <artifactId>ssem-cpu</artifactId>
  <packaging>jar</packaging>

  <name>SSEM CPU emulator</name>
  <description>Java-based SSEM CPU emulator</description>

  <build>
    <finalName>ssem-cpu</finalName>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-jar-plugin</artifactId>
        <configuration>
          <archive>
            <manifest>
              <addClasspath>false</addClasspath>
              <addDefaultImplementationEntries>true</addDefaultImplementationEntries>
              <addDefaultSpecificationEntries>true</addDefaultSpecificationEntries>
            </manifest>
          </archive>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
      </plugin>
    </plugins>
  </build>

  <dependencies>
    <dependency>
      <groupId>net.sf.emustudio</groupId>
      <artifactId>cpu-testsuite</artifactId>
    </dependency>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
    </dependency>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-nop</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>net.sf.emustudio</groupId>
      <artifactId>emuLib</artifactId>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
    </dependency>
    <dependency>
      <groupId>org.easymock</groupId>
      <artifactId>easymock</artifactId>
    </dependency>
  </dependencies>
</project>
----

We might extend the content with some plug-ins later.


== The main class

So, right to the code. We will start implementing the main class of the CPU. The purpose of the main class is to provide
information about the plug-in and enable let to control the plug-in running states by emuStudio main module.

The first snippet looks as follows:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/cpu/CpuImpl.java`
----
@PluginType(
    type = PLUGIN_TYPE.CPU,
    title = "SSEM CPU",
    copyright = "\u00A9 Copyright 2016, Your Name",
    description = "Emulator of SSEM CPU"
)
public class CpuImpl extends AbstractCPU {

    public CpuImpl(Long pluginID, ContextPool contextPool) {
        super(pluginID);
    }

    @Override
    protected void destroyInternal() {

    }

    @Override
    protected RunState stepInternal() throws Exception {
        return null;
    }

    @Override
    public JPanel getStatusPanel() {
        return null;
    }

    @Override
    public int getInstructionPosition() {
        return 0;
    }

    @Override
    public boolean setInstructionPosition(int i) {
        return false;
    }

    @Override
    public Disassembler getDisassembler() {
        return null;
    }

    @Override
    public void initialize(SettingsManager settingsManager) throws PluginInitializationException {

    }

    @Override
    public String getVersion() {
        return "1.0.0";
    }

    @Override
    public RunState call() throws Exception {
        return null;
    }
}
----

As you can see, there is a lot of methods which needs attention. And some more (like breakpoint support) are
already implemented in `AbstractCPU`. Don't worry, we'll get through all of them.
But first, we need to talk about responsibilities and behavioral contracts of a CPU - emuStudio plug-in.

== CPU in emuStudio: What we have here

Since emuStudio is not only emulator, it is also - and mainly - "development" IDE for people which want to program
emulated machines. Therefore, emuStudio provides nice debug window and other useful functionality. This functionality
can work only when all plug-ins allow interactive communication with emuStudio main module.

=== `getDisassembler()`

For example, when we were talking about debug window, CPU plug-in needs to provide a good disassembler to emuStudio,
which it then uses it and shows nice disassembled instructions to the user. The advantage of this is that emuStudio
can remain universal - various CPUs implement their own disassemblers.

We will get to it later. Fortunately, there exist tools which will help us to generate one.

=== `getStatusPanel()`

Each CPU in emuStudio must implement a `javax.swing.JPanel`, which should contain graphical components showing
everything useful to the user (e.g. registers, flags, etc.). The panel is then placed in the emulator
tab in the emuStudio main module.


== Behavioral contracts

=== Load and initialization

CPU plug-in is created as a second plug-in (first is compiler).

At first, emuStudio creates an instance of the plug-in.

=== Emulation control

If you are familiar with emuStudio, you know that there is a button above debug window, green filled arrow, by which
the emulation will be executed. Besides, there are more buttons, for example "step emulation", which will do execute
just one CPU instruction.

CPU plug-in (when inherited from `AbstractCPU`) supports this behavior by with only methods - `call()`, which should
start a loop of executing instructions from the current instruction pointer, and `stepInternal()`, which should execute
just one instruction and then return resulting `RunState` (both methods do).

The contract which needs attention is threading. Execution of mentioned methods is done always from emuStudio, because
other plug-ins don't have access to it (only if it is accessible from custom context, we'll talk about contexts later).
emuStudio main module has dedicated one single thread for this purpose. So the methods are not executed from UI thread.
This means they will not block UI, even if they take long time to execute.

All other methods from the CPU interface are (possibly) executed from UI thread, so they should be implemented in
a responsive manner, because they block UI.






