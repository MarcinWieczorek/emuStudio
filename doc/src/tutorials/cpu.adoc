= How to write a CPU for emuStudio
(c) Copyright 2006-2016, Peter Jakubƒço
Version 0.39
:toc:
:numbered:

This tutorial will describe some basic knowledge about how to create a CPU to be used in emuStudio. The tutorial
does not aim to explain emulation techniques in much detail, nor it is exhaustive. This is left for the programmer.
The tutorial focuses on how to use emuLib API in a CPU project so it can be used in emuStudio.

[[GETTING_STARTED]]
== Getting started

Before reading on, please read the "Introduction for writing virtual computers" document. It gives the information
needed for setting up the development environment and for basic understanding how the emuStudio/plug-ins lifecycle
work.

A CPU is just another plug-in, which means that it is enough to implement some API. The CPU
API can be found in `emulib.plugins.cpu` project package.

CPU is supposed to be the core of the emulator in the similar way as the real CPU is core to the computer.
The term "emulation technique" is usually used when we talk about CPU emulation. This tutorial will not cover
the techniques in much detail. Furthermore, only instruction interpretation will be used for its simplicity.

NOTE: More information about emulation techniques can be found for example at
      http://www.xsim.com/papers/Bario.2001.emubook.pdf[this link].


In this tutorial, a simple CPU will be implemented for the world's very first stored-program computer,
https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine[SSEM], nicknamed
"Baby". It was a predecessor of Manchester Mark 1 which led to Ferranti Mark 1, the world's first commercially available
general-purpose computer.

[[WHAT_CPU_DOES]]
== What emuStudio's CPU can do

CPU emulators in emuStudio are not just plain emulators. Besides, they must cooperate with emuStudio and provide
capabilities allowing debugging and some visualization.

The CPU must, besides the emulation "engine", implement:

- Disassembler
- Java Swing GUI panel

Disassembler will be used by emuStudio for creating the list of instructions in the debugger panel. The visualization
of CPU registers, possibly current frequency and run state must be implemented by the CPU plug-in. For that purpose
the plug-in must provide the GUI panel to CPU.

Both the disassembler and GUI panel should be instantiated only once. emuStudio will ask for them also only once, during
the process of loading of the virtual computer.

For developing disassembler, there is good news. There exist a tool which can generate emuStudio disassembler from
a specification file. We will use this tool also in this tutorial. For more information, see
https://github.com/sulir/edigen


== Preparing the environment

We will use Maven for managing the source code and dependencies.

NOTE: If you are new to Maven, please read
      https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html[Maven in 5 minutes] tutorial.


The project should be located in `emuStudio/plugins/cpu/ssem-cpu`.
In order to create the initial project structure, run `mvn archetype:generate` in that directory.

The following structure should now exist:

    src/
      main/
        java/
        resources/
    test/
      java/
    pom.xml


We will start with the `pom.xml` file, which follows.

[source,xml]
.`pom.xml`
----
include::../../../plugins/cpu/ssem-cpu/pom.xml[]
----

== The main class

So, right to the code. We will start implementing the main class of the CPU. The purpose of the main class is to provide
information about the plug-in and enable let to control the plug-in running states by emuStudio main module.

The first snippet looks as follows:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/cpu/CpuImpl.java`
----
@PluginType(
    type = PLUGIN_TYPE.CPU,
    title = "SSEM CPU",
    copyright = "\u00A9 Copyright 2016, Your Name",
    description = "Emulator of SSEM CPU"
)
public class CpuImpl extends AbstractCPU {

    public CpuImpl(Long pluginID, ContextPool contextPool) {
        super(pluginID);
    }

    @Override
    protected void destroyInternal() {

    }

    @Override
    protected RunState stepInternal() throws Exception {
        return null;
    }

    @Override
    public JPanel getStatusPanel() {
        return null;
    }

    @Override
    public int getInstructionPosition() {
        return 0;
    }

    @Override
    public boolean setInstructionPosition(int i) {
        return false;
    }

    @Override
    public Disassembler getDisassembler() {
        return null;
    }

    @Override
    public void initialize(SettingsManager settingsManager) throws PluginInitializationException {

    }

    @Override
    public String getVersion() {
        return "1.0.0";
    }

    @Override
    public RunState call() throws Exception {
        return null;
    }
}
----

As you can see, there is a lot of methods which needs attention. Note two methods especially - `getStatusPanel()`
and `getDisassembler()`. Those two methods should return the components mentioned in section <<WHAT_CPU_DOES>>.

Also note that the class extends from `AbstractCPU`. The `AbstractCPU` class lies in emuLib library. It implements
some fundamental methods required by `CPU` interface. For example, managing breakpoints and controlling the
high-level emulation lifecycle in a thread-safe way. Generally speaking, the class eliminates lots of repeated
boiler-plate code needed to be done in every CPU plug-in.

[[BEHAVIORAL_CONTRACTS]]
== Behavioral contracts

=== Load and initialization

Loading the virtual computer starts with creating separate class loader derived from the one emuStudio is using,
so each plug-in can see everything what emuStudio can see. There can be loaded only one computer in emuStudio.

The CPU plug-in JAR file is loaded using the class loader as a second in order.

The loading process follows:

1. JAR content is searched for a main class. Main class must be annotated with `@PluginType(type = PLUGIN_TYPE.CPU)`
   annotation and it does not matter in which package it resists.

2. There must be just one main class in the JAR. If there are more classes annotated with mentioned annotation, the
   first found will be used; however the search order is non-deterministic.

2. The main class must implement `emulib.plugins.cpu.CPU` interface (in any depth of inheritance).

3. Plug-in is instantiated by calling the main class constructor. The constructor must be public and must have two
   parameters of type: `java.lang.Long` (as the first) and `emulib.runtime.ContextPool` (as the second). The first
   parameter represents a unique plug-in ID assigned by emuLib. This ID can then be used to access configuration
   of the emulated computer. The second parameter is a context pool object. It is a pool of plugin contexts, runtime
   entities intended for the plug-in intercommunication. In the constructor, the CPU should initialize its context to
   the context pool. However; it must not retrieve the contexts of other plugins now, because they are not present at
   this point, except compiler.

4. Plug-in is initialized by calling method `emulib.plugins.Plugin.initialize(SettingsManager settingsManager)` from
   the main thread of emuStudio (not UI thread). This method is intended for all the initialization which could not be
   performed in the constructor, such as reading plug-in settings, or retrieving contexts of other plug-in(s) from
   the context pool.

5. Specifically for CPU, emuStudio calls `getDisassembler()` and `getStatusPanel()` methods in unspecified order.

After those steps, the CPU plug-in is ready. Further work of the CPU is event-based. emuStudio will handle UI events
and control the plug-in by calling appropriate methods of the main class instance. CPU emulators are run in
different thread than UI thread, so all method calls come from the same "controller" thread.

In case of automatic emulation, the emulation control is performed only in the main thread.

=== Emulation lifecycle

As it was described in section "Emulation lifecycle" in the user manual of the main module, the emulation "life"
is a state machine. This state machine can react on events from outside world which cause changes, so-called transitions
to another state.

For example, you know that there is a button above debug window, green-filled arrow, by which
the emulation will be executed. Besides, there are more buttons, for example "step emulation", which will do execute
just one CPU instruction.

The state machine can be seen in the following diagram:

[graphviz]
---------------------------------------------------------------------
digraph emulation_states {
  ratio = 1;
  node [shape = rect];

  breakpoint [ style = filled, fillcolor=lightgrey ];
  stopped [shape = doubleoctagon ];

  breakpoint -> running [ label = "run " ];
  breakpoint -> stopped [ label = "stop " ];
  breakpoint -> breakpoint   [ label = "step " ];
  running -> stopped [ label = "stop, error " ];
  running -> breakpoint [ label = "pause, reset " ];
  stopped -> breakpoint [ label = "reset " ];
}
---------------------------------------------------------------------

The states of the state machine are coded into a enum in emuLib:

[source,java]
.`emulib.plugins.cpu.CPU.RunState`
----
public static enum RunState {
    STATE_STOPPED_NORMAL("stopped"),
    STATE_STOPPED_BREAK("breakpoint"),
    STATE_STOPPED_ADDR_FALLOUT("stopped (address fallout)"),
    STATE_STOPPED_BAD_INSTR("stopped (instruction fallout)"),
    STATE_RUNNING("running");

    ...
}
----

The initial state is `breakpoint`. This is a behavioral contract which all CPUs must fulfil.

The `AbstractCPU` class implements the state machine by implementing fundamental methods of the `CPU` interface:

[source,java]
.`emulib.plugins.cpu.CPU`
----
public interface CPU extends Plugin {

    void step();

    void execute();

    void pause();

    void stop();

    void reset(int memoryLocation);

    ...
}
----

The CPU plug-in developer using `AbstractCPU` must implement only the following methods:

[source,java]
.`emulib.plugins.cpu.AbstractCPU`
----
@ThreadSafe
public abstract class AbstractCPU implements CPU, Callable<RunState> {
    protected abstract RunState stepInternal() throws Exception;

    protected abstract void resetInternal(int var1);

    protected abstract void destroyInternal();

    ...
}
----

==== CPU emulation modes


The CPU can work in two modes while performing the emulation: "step" and "run" mode. The modes are disjunct - only one
of them can be active in time. In addition, these modes are not "real" in terms of implementation requirements, but they
serve as a good abstraction.

===== "Step" mode

In the "step" mode, the CPU emulates instructions in "steps", one-by-one. One instruction should be emulated by calling
`step()` method. After the emulation of the instruction is finished, the CPU run state should be returned back to
`STATE_STOPPED_BREAK`.

In case of error, the run state should change to `STATE_STOPPED_(how)`, where `(how)` is the general root cause of the
error (e.g. `BAD_INSTR` or `ADDR_FALLOUT`).

In this mode, it is not required to emulate the instruction in a performance-optimized manner.

===== "Run" mode

In the "run" mode, the CPU should emulate instructions infinitely until either some CPU-halt instruction is encountered
or user stops the emulation by external GUI event. Within this mode the developer is encouraged to use some good
emulation technique, which can focus on performance. The code paths which will be run by JVM in this mode should be
optimized for performance.

Furthermore, emuStudio will stop disassembling instructions and also other performance-consuming tasks to let the CPU
and other virtual computer components provide the best emulation experience.

When the emulation is finished, the run state should be set accordingly.

===== Final notes

Those modes are reflected in methods of `AbstractCPU` class. The `call()` method representing the "run" mode, and
`stepInternal()` method, representing the `step` mode.

The contract which needs attention is threading. Execution of mentioned methods is done always by emuStudio.
It has dedicated one thread for this purpose. The methods are never executed from UI thread, but from the dedicated
thread, using a work-queue for the upcoming events.

This means that CPU emulation control will not block UI, even if the execution takes longer time.
However, all the other methods from the CPU interface are (possibly) executed from UI thread, so they should be
implemented in a responsive manner; they can block.

[[SSEM_ARCHITECTURE]]
== Architecture of SSEM CPU emulator

SSEM is one of the first implementations of the von-Neumann design of a computer. It contained control unit,
arithmetic-logic unit and I/O subsystem (CRT display). More information about the real architecture can be found
at http://www.cs.ubc.ca/~hilpert/e/SSEM/[this link].

The architecture of our SSEM CPU emulator will look as follows (below is Display and Memory just to show how it
is connected overall):

[graphviz]
---------------------------------------------------------------------
digraph ssem_cpu_architecture {
  node [shape = rect];

  subgraph clustercpu {
    style=filled;
    color=lightgrey;
    fillcolor=lightgrey;

    subgraph regs {
      rank ="source";

      CI [ label = "CI" ];
      ACC [ label = "Accumulator" ];
    }

    subgraph other {
      rank ="same";

      E [ label ="Engine" ];
      D [ label ="Disassembler" ];
      P [label = "GUI Panel" ];
    }

    label = <<B>SSEM CPU</B>>;
  }

  subgraph a {
    rank = "same";
    node [style=filled];

    M [label = <<B>Memory</B>> ];
    DIS [label =<<B>Display</B>>];
  }

  E -> CI;
  E -> ACC;
  P -> CI;
  P -> ACC;

  D -> M;
  E -> M;
  DIS -> M;
}
---------------------------------------------------------------------



== Implementing CPU fundamentals

The fundamental steps when building a CPU involves the initialization and destruction code. After reading the
<<BEHAVIORAL_CONTRACTS>>, you should be aware of how the code should look like.

The initialization code is represented by the constructor and the `initialize()` method.


[source,java]
.`src/main/java/net/sf/emustudio/ssem/cpu/CpuImpl.java`
----
public class CpuImpl extends AbstractCPU {
    private final ContextPool contextPool;

    public CpuImpl(Long pluginID, ContextPool contextPool) {
        super(pluginID);
        this.contextPool = Objects.requireNonNull(contextPool);
    }

    @Override
    public String getVersion() {
        return "1.0.0";
    }

    ...
}
----

We will leave the other methods unimplemented for now.

While getting to the initialization part, what the CPU needs in order to operate? Especially, our SSEM "CPU". It
requires memory. The I/O subsystem, as can be seen at the picture under <<SSEM_ARCHITECTURE>> section, will not be
implemented here. As we will do in another tutorial, our "display" device will show only the memory content and will
not have any connection to CPU.

So let's initialize the CPU by getting the memory.

[source,java]
.`src/main/java/net/sf/emustudio/ssem/cpu/CpuImpl.java`
----
public class CpuImpl extends AbstractCPU {
    private MemoryContext<Integer> memory;

    @Override
    public void initialize(SettingsManager settingsManager) throws PluginInitializationException {
        memory = contextPool.getMemoryContext(getPluginID(), MemoryContext.class);
    }
}
----

Now we see what the context pool is used for. It is a "storage" of communication objects which plug-ins provide
(contexts). Other plug-ins, which are connected with the one they want to communicate with, ask for the context.
There exist many specific contexts - for CPU, for Compiler, Memory or Device. Also, the context can be extended
with another non-standard methods. In that case, the context class should be passed as the second argument when
calling `get...Context()`. In our case, we expect the standard one, so we pass `MemoryContext.class` as the second
argument.

What now? We need to implement three fundamental things - GUI panel, Disassembler and the emulator engine itself.
We can start with the interesting stuff right away.

== Emulator engine

Emulator engine is the core of the emulator. As we all probably know, the CPU interprets some binary-encoded commands,
which are stored in memory. Basic von-Neumann CPUs work sequentially. Performing one instruction consists of four
steps: fetch, decode and execute, store. When we would like to program these steps in a programming language like Java,
the phases will be probably overlap and they can be quite hard to distinguish. It is not our intent to preserve the
exact phases in the emulator. This is the main difference from a simulator. Emulator "looks" like real computer,
"behaves" like the real one, but inside it is normal program which was written by any programming style, uses various
variables, methods and other language features.

The pseudo-algorithm for performing one instruction can look as follows:

----
step() {
  // fetch phase
  instruction = memory.read(current_instruction);
  current_instruction = current_instruction + 1;

  // decode phase
  line = parseLine(instruction);
  opcode = parseOpcode(instruction);

  // execute phase
  switch (opcode) {
    case 0: // JMP
      ...
    case 4: // JPR
      ...
    ...
  }
}
----

And what CPU does when it runs? It does these steps in a infinite loop. So the main CPU emulation algorithm, also
called "interpretation" can look as follows:

----
run() {
  while (!stopped) {
    step();
  }
}
----

NOTE: In Java, besides interpretation it is possible to write threaded dispatch algorithm, with usage of Reflection or
      lambdas feature. Threaded dispatch stores the execution implementation of each instruction in separate method.
      Then, there is a dispatch table (array of method references), which maps the methods by opcode. Then, after the
      decoding the opcode, the instruction is executed just by indexing that table and executing the method it
      references to. This algorithm is faster than interpretation.

Our emulator engine will be constructed as a separate class. Besides the emulation methods it will contain the
variables representing CPU registers - `CI` (current instruction) and `Acc` (accumulator). In SSEM, both are 32-bit
values.

The class looks as follows:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/cpu/EmulatorEngine.java`
----
public class EmulatorEngine {

    private final MemoryContext<Integer> memory;
    private volatile CPU.RunState currentRunState;

    public volatile int Acc;
    public volatile int CI;

    public EmulatorEngine(MemoryContext<Integer> memory) {
        this.memory = Objects.requireNonNull(memory);
    }

    public void reset(int startingPos) {
        Acc = 0;
        CI = startingPos;
    }

    public CPU.RunState step() {
        int instruction = memory.read(CI);
        CI++;

        int line = parseLine(instruction);
        int opcode = parseOpcode(instruction);

        switch (opcode) {
            case 0: // JMP
                CI = memory.read(line);
                break;
            case 4: // JPR
                CI = CI + memory.read(line);
                break;
            case 2: // LDN
                Acc = -memory.read(line);
                break;
            case 6: // STO
                memory.write(line, Acc);
                break;
            case 1: // SUB
                Acc = Acc - memory.read(line);
                break;
            case 3: // CMP / SKN
                if (Acc < 0) {
                    CI++;
                }
                break;
            case 7: // STP / HLT
                return CPU.RunState.STATE_STOPPED_NORMAL;
        }
        return CPU.RunState.STATE_STOPPED_BAD_INSTR;
    }

    private int parseLine(int instruction) {
        int line = instruction >> 27;
        return ((line & 1) << 4)
                | ((line & 2) << 2)
                | (line & 4)
                | ((line & 8) >> 2)
                | ((line & 16) >> 4);
    }

    private int parseOpcode(int instruction) {
        return (instruction >> 16) & 3;
    }

    public CPU.RunState run() {
        while (!Thread.currentThread().isInterrupted() && currentRunState == CPU.RunState.STATE_RUNNING) {
            try {
                currentRunState = step();
            } catch (IllegalArgumentException e) {
                if (e.getCause() != null && e.getCause() instanceof IndexOutOfBoundsException) {
                    return CPU.RunState.STATE_STOPPED_ADDR_FALLOUT;
                }
                return CPU.RunState.STATE_STOPPED_BAD_INSTR;
            } catch (IndexOutOfBoundsException e) {
                return CPU.RunState.STATE_STOPPED_ADDR_FALLOUT;
            }
        }
        return currentRunState;
    }

}
----

Pretty short, huh? Method `step()` and `run()` return `CPU.RunState` enum, which is used by emuStudio to determine
if the emulator is still running or in what state it is. The `step()` method is the most fundamental regarding the
instruction emulation, but it is so easy that we'll rather talk about the `run()` method.

The `run()` method begins with the already described cycle. However, the conditions of determining if the CPU should
be running can look complex at the first sight. However, we are checking just two conditions - if the current run state
has changed (look at the `step()` method - it can change there), or if the current thread is interrupted. It can
interrupt by external condition, e.g. when somebody quits the emulator during CPU emulation.

Then, there are many catches. They are quite required because of many possible situations which can happen - when the
CPU gets to the end of the memory, what it should do? It does nothing, so the memory will throw some variant of
`IndexOutOfBoundsException`. For this purpose, CPU state contains one which is called `STATE_STOPPED_ADDR_FALLOUT`,
meaning "address fallout", like if the address "fell out" of allowed range.

And the last bad thing which can happen is when the memory at the current instruction position contains some unknown
data, not recognized by CPU. For this situation, we have `STATE_STOPPED_BAD_INSTR` state.

That's pretty it. We will now extend the engine to support breakpoints and controlling the speed.

=== Breakpoints support

Since emuStudio is mainly intended for students, as they should get in touch with emulated computers and how they work,
it should allow sometimes to pause the emulation at a point where student wants. This capability is also useful when
our program written for the emulated computer does not work and we want to know what happens after executing specific
instruction. We can then set a "breakpoint" to that instruction, and emuStudio will stop just before its execution.

Breakpoint is in fact an address - memory location, at which the CPU should pause its execution. It is used only when
CPU is running. Breakpoints are usually stored in a set. The class `emulib.plugins.cpu.AbstractCPU` has already this
set and implements all the breakpoints setting/unsetting. What is still left to do for us is to check if at specific
address (current instruction position) the breakpoint is set, and if yes, somehow "pause" the CPU.

We implement this in the `run()` method, right before instruction execution:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/cpu/EmulatorEngine.java`
----
public class EmulatorEngine {
    ...
    private final CPU cpu;

    public EmulatorEngine(Memorytry {Context<Integer> memory, CPU cpu) {
        this.memory = Objects.requireNonNull(memory);
        this.cpu = Objects.requireNonNull(cpu);
    }

    public CPU.RunState run() {
        while (...) {
            try {
                if (cpu.isBreakpointSet(CI)) {
                    return CPU.RunState.STATE_STOPPED_BREAK;
                }
                currentRunState = step();
            } catch (...) {
              ...
            }
        }
        return currentRunState;
    }

    ...
}
----

Now the engine besides memory requires also the CPU instance, needed for checking if the breakpoint is set at current
instruction, denoted by `CI` register. If the breakpoint is set, the resulting state is `STATE_STOPPED_BREAK`, and
emuStudio will take care about the pausing and updating GUI.

=== Preserving the speed

Every real computer runs at some speed, usually referring only CPU speed. Baby "CPU" could perform about 700
instructions per second. How we should achieve that? The simplest method would be something like that:

----
run() {
    while (!stopped) {
        start = measureTime();
        ... perform 700 instructions ...
        end = measureTime();

        to_wait = 1.second - (end - start);
        if (to_wait > 0) {
            wait_time(to_wait);
        }
    }
}
----

So perform 700 instructions, then wait until one second elapses, and go again. What's wrong about this solution?
That the algorithm is not "smooth". 700 instructions will be performed at full blast, and then there will be something
like a "break", and the situation will repeat. Real CPU certainly didn't work like that and we can do better.

In reality, every instruction is performed in some number of machine "cycles". We can imagine the machine cycle
as a time of elementary phase when performing the instruction. For example, instruction phases are fetch, decode,
execute and store. Each of these phases can take various time for particular instruction. Instructions which operate
with memory can have shorter execute phase, but longer fetch/store phases. On the other hand, arithmetic instructions
can have shorter fetch/store phases but a bit longer execute phase. And so on. Based on this information which is
usually available, can be build a technique for preserving speed even better.

NOTE: Description of the speed-preservation technique can be seen e.g. at
      http://emustudio.sourceforge.net/downloads/2010-cse.pdf[this link].

However, for purposes of this tutorial we will implement different algorithm, but also quite interesting. The idea
is based on measuring average time which takes the execution of one instruction. The measurement will not be very
accurate, since perfect or almost perfect measuring of method execution in Java has some rules, like warming up JVM
before measurement, etc.

NOTE: For time measurement it is necessary to use `System.nanoTime()` method instead of `System.currentTimeMillis()`.
      The reason is that the latter is corrected time-to-time by operating system because of errors caused by not
      really accurate timer in your computer. Then, the time difference can give invalid values, sometimes even
      negative ones. The `System.nanoTime()` is not corrected, so time difference works well.

The algorithm will work in the following steps:

----
1. Measure average instruction time
2. Compute how much CPU should wait after executing each instruction
3. Wait after each instruction for the computed time
----

The third step will be performed only if the time we should wait is greater than zero. It means that the host computer
is faster than Baby computer (which is expected).

The algorithm can be implemented as follows:

[source,java]
----
public class EmulatorEngine {
    ...
    private volatile long averageInstructionNanos;

    public CPU.RunState run() {
        if (averageInstructionNanos == 0) {
            measureAverageInstructionNanos();
        }
        long waitNanos = TimeUnit.SECONDS.toNanos(1) / averageInstructionNanos;
        while (...) {
            ...
            if (waitNanos > 0) {
                LockSupport.parkNanos(waitNanos);
            }
        }
        return currentRunState;
    }

    ...
}
----

Quite simple, so far. We will measure the instruction speed just once, on the first call of the `run()` method. The
measured value will be reused for later executions and will not slow down the whole emulator.

However, how we should measure the average time which is taken by the instruction execution?
Well, if we want to be at least somehow accurate, we should emulate the `step()` method several times, and then compute
the average. However, we can't. The reason is that `step()` method uses real memory and CPU registers. We should use
kind of "fake" the `step()` method which will not change the emulator state or memory. But the fake step should implement
instruction with the average "complexity", which we will do just with some estimation or better - feeling. The
algorithm can look as follows (there's lot to improve ofcourse):

.`src/main/java/net/sf/emustudio/ssem/cpu/EmulatorEngine.java`
----
public class EmulatorEngine {
    ...

    private void fakeStep() {
        int instruction = memory.read(CI);
        CI++;

        int line = parseLine(instruction);
        int opcode = parseOpcode(instruction);

        switch (opcode) {
            case 0: break;
            case 1: break;
            case 2: break;
            case 3: break;
            case 4: break;
            case 6: break;
            case 7: break;
        }

        Acc -= memory.read(line);
    }


    private void measureAverageInstructionNanos() {
        int oldCI = CI;
        int oldAcc = Acc;

        long start = System.nanoTime();
        for (int i = 0; i < INSTRUCTIONS_PER_SECOND; i++) {
            fakeStep();
        }
        long elapsed = System.nanoTime() - start;

        averageInstructionNanos = elapsed / INSTRUCTIONS_PER_SECOND;

        CI = oldCI;
        Acc = oldAcc;
    }

    ...
}
----

At first, we will save the registers (emulator state). Then, we will execute the fake step for 700 times and then
compute the average time. At the end we restore the state, and that's it. As you might notice, we tried to use
real things in this "fake" step method like real memory (but just for reading), and emulator registers, which we backed
up and then restored.

That's about it! If we had disassembler and GUI, the emulator is now ready - we just implemented the core of the CPU.

== Disassembler

Disassembler is not needed for the emulation itself. It is needed for emuStudio to be able to visually show the
instructions. Instructions are encoded in binary form and reside in memory. Disassembler "disassembles" - decodes the
instructions and transforms them into string representation which can be easily shown on screen.

Decoding binary instructions for disassembler can be a bit different from decoding used in the emulator. For example,
instructions binary code can use constants which can be used directly in the emulator, but which must be translated
in the disassembler. Also, decoding code is usually mixed up with emulator code for performance reasons, so it's
hard to reuse it. For these reasons, the programmer often need to implement the decoding part again and duplicate the
work a bit. But not in emuStudio.

Fortunatelly, there exist a project called `edigen` ( ... .. ... .), a disassembler generator. It works similarly as
a parser generator: developer writes a specification file with all the instructions of the CPU. Then, edigen (either
from the command line or from Maven) generates disassembler and decoder source code from predefined templates. These
generally do not need any further attention from the developer and can be used right away.

SSEM CPU specification file should be put in `ssem-cpu/src/main/edigen/cpu.eds`, and it looks as follows:

[source]
.`ssem-cpu/src/main/edigen/cpu.eds`
----
include::../../../plugins/cpu/ssem-cpu/main/edigen/cpu.eds[]
----

The specification file might look a bit cryptic at first sight, but it's quite easy. The content is divided into two
sections, separated with two `%%` chars on a separate line. The first section contains rules which are used for parsing
the instruction binary codes and assign labels to the codes. The second section specifies the disassembled string
formats for particular rules.

There can exist multiple rules, and rules can include another rules. If the rule includes the same rule recursively,
it means it's a constant. In that case, in the parenthesis after the rule inclusion must be a number of bits
which the constant takes.

=== Using generated disassembler

When you look into our `pom.xml` file, you can find a section:

[source,xml]
----
...
      <plugin>
        <groupId>edigen</groupId>
        <artifactId>edigen-maven-plugin</artifactId>
        <configuration>
          <decoderName>net.sf.emustudio.ssem.DecoderImpl</decoderName>
          <disassemblerName>net.sf.emustudio.ssem.DisassemblerImpl</disassemblerName>
        </configuration>
        <executions>
          <execution>
            <goals>
              <goal>generate</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
...
----

The disassembler will be generated in the class `net.sf.emustudio.ssem.DisassemblerImpl`. The class already implements
the interface `emulib.plugins.cpu.Disassembler`, which is exactly what method `CPU.getDisassembler()` returns.
Disassembler is an independent component so it also uses the memory from where it reads the instructions. Therefore,
disassembler can be initialized _after_ the memory. Now we are ready to do full initialization of the emulator, with
the engine as well as disassembler. The code looks as follows:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/cpu/CpuImpl.java`
----
public class CpuImpl extends AbstractCPU {
    ...
    private EmulatorEngine engine;
    private Disassembler disasm;

    ...

    @Override
    public void initialize(SettingsManager settingsManager) throws PluginInitializationException {
        memory = contextPool.getMemoryContext(getPluginID(), MemoryContext.class);
        disasm = new DisassemblerImpl(memory, new DecoderImpl(memory));
        engine = new EmulatorEngine(memory, this);
    }

    @Override
    public Disassembler getDisassembler() {
        return disasm;
    }

    @Override
    public RunState call() throws Exception {
        return engine.run();
    }

    @Override
    protected RunState stepInternal() throws Exception {
        return engine.step();
    }

    @Override
    protected void resetInternal(int startPos) {
        engine.reset(startPos);
    }

    @Override
    public int getInstructionPosition() {
        return engine.CI;
    }

    @Override
    public boolean setInstructionPosition(int i) {
        int memSize = memory.getSize();
        if (i < 0 || i >= memSize) {
            throw new IllegalArgumentException("Instruction position can be in <0," + memSize +">, but was: " + i);
        }
        engine.CI = i;
        return true;
    }

}
----

We are approaching the end of our road. The last thing to do is to implement a status panel GUI of the CPU.

== Status panel

The status panel is a Java Swing panel (class extending `java.swing.JPanel`). The GUI can be "drawn" in any favorite
IDE, like NetBeans or IntelliJ IDEA. The status panel should show the following:

- CPU run state
- Internal state: registers or possibly portion of memory
- Optionally, speed (running frequency)

The status panel is the interaction point between CPU and the user. With it, the user can be allowed to modify or
view the internal status of the CPU emulator which is very handy when learning or checking how it works, what the
registers' values really are (and compare them with those shown on a display), etc.

SSEM CPU status panel will look as follows:

image::tutorials/images/cpu-status-panel.png[SSEM CPU Status panel GUI]

The class code is:

[source,java]
.`ssem-cpu/src/main/java/net/sf/emustudio/ssem/cpu/CpuPanel.java`
----
public class CpuPanel extends javax.swing.JPanel {
    private final EmulatorEngine engine;
    private final Updater updater;

    public CpuPanel(CPU cpu, EmulatorEngine engine) {
        this.engine = Objects.requireNonNull(engine);
        this.updater = new Updater();

        initComponents();
        cpu.addCPUListener(updater);
        lblSpeed.setText(String.valueOf(EmulatorEngine.INSTRUCTIONS_PER_SECOND));
    }

    private final class Updater implements CPU.CPUListener {

        @Override
        public void runStateChanged(CPU.RunState rs) {
            lblRunState.setText(rs.toString().toUpperCase());
        }

        @Override
        public void internalStateChanged() {
            int acc = engine.Acc;
            int ci = engine.CI;

            txtA.setText(String.format("%8x", acc));
            txtCI.setText(String.format("%8x", ci));

            txtBinA.setText(formatBinary(acc));
            txtBinCI.setText(formatBinary(ci));
        }

        private String formatBinary(int number) {
            String binNumber = Integer.toBinaryString(number);
            binNumber = String.format("%32s", binNumber).replace(" ", "0");

            String[] splitted = binNumber.split("\\d\\d\\d\\d");
            return splitted[0] + ' ' + splitted[1] + "  "
                    + splitted[2] + ' ' + splitted[3] + "  "
                    + splitted[4] + ' ' + splitted[5] + "  "
                    + splitted[6] + ' ' + splitted[7];
        }

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.JPanel jPanel1 = new javax.swing.JPanel();
        lblRunState = new javax.swing.JLabel();
        javax.swing.JLabel jLabel7 = new javax.swing.JLabel();
        lblSpeed = new javax.swing.JLabel();
        javax.swing.JPanel jPanel2 = new javax.swing.JPanel();
        javax.swing.JLabel jLabel2 = new javax.swing.JLabel();
        javax.swing.JLabel jLabel3 = new javax.swing.JLabel();
        txtCI = new javax.swing.JTextField();
        txtA = new javax.swing.JTextField();
        txtBinA = new javax.swing.JTextField();
        txtBinCI = new javax.swing.JTextField();

        jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Run control", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 1, 11))); // NOI18N

        lblRunState.setFont(new java.awt.Font("Monospaced", 0, 18)); // NOI18N
        lblRunState.setForeground(java.awt.Color.blue);
        lblRunState.setText("BREAKPOINT");

        jLabel7.setFont(jLabel7.getFont().deriveFont(jLabel7.getFont().getStyle() | java.awt.Font.BOLD));
        jLabel7.setText("ins/s");

        lblSpeed.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        lblSpeed.setText("0");
        lblSpeed.setToolTipText("Speed");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lblRunState)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(lblSpeed)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel7)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblRunState)
                    .addComponent(jLabel7)
                    .addComponent(lblSpeed))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Registers", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 1, 11))); // NOI18N

        jLabel2.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        jLabel2.setText("A");
        jLabel2.setToolTipText("Accumulator");

        jLabel3.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        jLabel3.setText("CI");
        jLabel3.setToolTipText("Control Instruction");

        txtCI.setEditable(false);
        txtCI.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        txtCI.setText("0");

        txtA.setEditable(false);
        txtA.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        txtA.setText("0");

        txtBinA.setEditable(false);
        txtBinA.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        txtBinA.setText("0000 0000  0000 0000  0000 0000  0000 0000");

        txtBinCI.setEditable(false);
        txtBinCI.setFont(new java.awt.Font("Monospaced", 0, 12)); // NOI18N
        txtBinCI.setText("0000 0000  0000 0000  0000 0000  0000 0000");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel2)
                        .addGap(11, 11, 11)
                        .addComponent(txtA, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(txtCI, javax.swing.GroupLayout.PREFERRED_SIZE, 95, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(txtBinA)
                    .addComponent(txtBinCI))
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(txtA, javax.swing.GroupLayout.PREFERRED_SIZE, 20, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(txtBinA, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel3)
                    .addComponent(txtCI, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(txtBinCI, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel2, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel lblRunState;
    private javax.swing.JLabel lblSpeed;
    private javax.swing.JTextField txtA;
    private javax.swing.JTextField txtBinA;
    private javax.swing.JTextField txtBinCI;
    private javax.swing.JTextField txtCI;
    // End of variables declaration//GEN-END:variables
}
----

We don't have to care about method `initComponents()` and the fields at the end of the class. Those are generated by
the NetBeans by its GUI designer. I have included it just because the overall look and how the variables - text fields
etc. are named.

The only thing which should grasp our attention is the nested `Updater` class. The class implements the mechanism of
updating values of the GUI. The mechanism is the observer pattern, as you might have recognized. The updater implements
`CPU.CPUListener` interface, with two methods. The `runStateChanged()` method is called by the CPU when the run state
has changed. The argument is the new run state. The second method, `internalStateChanged()` is called by CPU always
when the internal state of a CPU has changed - ie. values of registers. When the CPU is in running state, this method
is not called for performance reasons.

NOTE: Don't forget to register the updater by calling `cpu.addCPUListener()`. The proper way upon shutting down should
      be to remove it, but the class `AbstractCPU` will take care about it.

Now we need to incorporate the panel into the main class. It's easy:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/cpu/CpuImpl.java`
----
public class CpuImpl extends AbstractCPU {

    @Override
    public JPanel getStatusPanel() {
        return new CpuPanel(this, engine);
    }

}
----

== Testing the CPU

Now you have implemented complete CPU emulator. It should work. Should. But how do we now until we try? Every program
can have bugs. And most likely it does. It is crucial for CPU emulator to work literally exactly as the real CPU. With
little playing we can't test all instructions, all their variants and check all possible inputs. This must be done
systematically.

In languages which have mutable state ("inpure languages"), like Java, it is quite hard to reason about the correctness.
There are some ways, but instead of formal reasoning became very popular a technique called automated testing. There
exist several levels of automated tests. Those which are usually placed very close to the source code of the project,
and which tests a single "unit" - the smallest entity - are called unit tests.

In object oriented languages, unit tests should test production classes and their behavior in the isolated
environment. Each unit test is also a class. Maven uses standard path where the unit tests should be put.

Testing of SSEM CPU is left as an excercise for the plug-in developer.
