= How to write a memory for emuStudio
(c) Copyright 2006-2016, Peter Jakubčo
Version 0.39
:toc:
:numbered:

This tutorial will describe some basic knowledge about how to create an operating memory to be used in emuStudio.
In emuStudio computers have usually conform to von-Neumann architecture, which includes a memory as a separate
component. The tutorial focuses on how to use emuLib API in a Memory project so it can be used in emuStudio.

[[GETTING_STARTED]]
== Getting started

Within this tutorial, we will implement a main store of SSEM "Baby" machine, to conform with other tutorials for other
plug-ins. Before we start, here's a few words about what purpose and capabilities memories in emuStudio can have.

In first computers, operating memory was connected only with CPU. It means that all data transfer between the memory
and devices was done only through CPU. When data from memory was required, CPU "paused" executing instructions and
accessed the memory in the meantime. Later, DMA (direct memory access) capability was introduced, which allowed devices
to directly access the memory. In emuStudio, you can connect the memory with devices, or even with a compiler which
is the source of the emuStudio versatility and power.

There are three main behavioral contracts which need to be taken into account, when creating memory plug-in:

- Memory can be connected with none, one or more plug-ins of any type
- Memory plug-in is necessary for creating a virtual machine (emuStudio requires it)
- Operations of memory can be extended using special class called "context"

The implication is that the memory can be shared across CPU and devices, and the communication can be optimized with
custom operations. The context class is a customization which extends default context behavior. This tutorial will
cover some basics in this topic.

=== SSEM memory

SSEM used the world's first random-access memory called Williams or Williams-Kilburn tube
footnote:[See https://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine#Williams-Kilburn_tube]. The
used principle was the same as in standard Cathode-Ray-Tubes (CRTs). Original EDSAC computer (which introduced the
von Neumann architecture) did not have random-access memory.

The memory had 32 memory cells (called words), each had size of 32 bits. The memory could contain instructions and
data. So, one SSEM instruction perfectly fits in the single memory word.

Within this tutorial, we will hardcode the word size and memory size. But we'll also implement a GUI for the memory.
The code might seem complicated and bloated with a boiler-plate. For this simple computer, it definitely is. However,
much of which must be done will be really handy when implementing more complex computers.

== Preparing the environment

In order to start developing the memory, create new Java project. Here, Maven will be used for dependencies management.
The plug-in will be implemented as another standard emuStudio plug-in, so it will inherit Maven plug-in dependencies
from the main POM file.

The project should be located at `emuStudio/plugins/mem/ssem-mem`, and should contain the following structure:

    src/
      main/
        java/
        resources/
    test/
      java/
    pom.xml

NOTE: Note the naming of the plug-in. It follows the naming convention as described in the
      "Introduction for writing virtual computers" guide.

The POM file of the project might look as follows:

[source,xml]
----
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <parent>
    <groupId>net.sf.emustudio</groupId>
    <artifactId>emustudio-parent</artifactId>
    <version>0.39-SNAPSHOT</version>
    <relativePath>../../..</relativePath>
  </parent>

  <artifactId>ssem-mem</artifactId>
  <packaging>jar</packaging>

  <name>SSEM Memory</name>
  <description>Operating memory (main store) for the SSEM computer</description>

  <build>
    <finalName>ssem-mem</finalName>
    <plugins>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-jar-plugin</artifactId>
        <configuration>
          <archive>
            <manifest>
              <addClasspath>false</addClasspath>
              <addDefaultImplementationEntries>true</addDefaultImplementationEntries>
              <addDefaultSpecificationEntries>true</addDefaultSpecificationEntries>
            </manifest>
          </archive>
        </configuration>
      </plugin>
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-dependency-plugin</artifactId>
      </plugin>
    </plugins>
  </build>

  <dependencies>
    <dependency>
      <groupId>net.sf.emustudio</groupId>
      <artifactId>emuLib</artifactId>
    </dependency>
    <dependency>
      <groupId>org.slf4j</groupId>
      <artifactId>slf4j-api</artifactId>
    </dependency>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
    </dependency>
    <dependency>
      <groupId>org.easymock</groupId>
      <artifactId>easymock</artifactId>
    </dependency>
  </dependencies>
</project>
----

And let's start with the first Java class, the main plug-in class. Let's put it to package
`net.sf.emustudio.ssem.memory`, and call it `MemoryImpl`.

== Implementing basic stuff

Go to the `MemoryImpl` class source. Extend the class from `emulib.plugins.compiler.AbstractMemory` class.
The class extends from `Memory` interface and implements the most common methods, usable by all memories.

It is also necessary to annotate the class with `emulib.annotations.PluginType` annotation, and pass the
one argument of the constructor to the super class. The code snippet looks as follows:

[source,java]
.`src/main/java/net/sf/emustudio/ssem/memory/MemoryImpl.java`
----
package net.sf.emustudio.ssem.assembler;

import emulib.annotations.PLUGIN_TYPE;
import emulib.annotations.PluginType;
import emulib.plugins.memory.AbstractMemory;
import emulib.runtime.ContextPool;

@PluginType(
        type = PLUGIN_TYPE.MEMORY,
        title = "SSEM memory",
        copyright = "\u00A9 Copyright 2016, Peter Jakubčo",
        description = "Main store for SSEM machine"
)
public class MemoryImpl extends AbstractMemory {
    private final static Logger LOGGER = LoggerFactory.getLogger(MemoryImpl.class);

    public MemoryImpl(Long pluginID, ContextPool contextPool) {
        super(pluginID);
    }

    // ... other methods ...
}
----

NOTE: The constructor presented here is mandatory. This is one of the behavioral contracts, emuStudio expects
      that a plug-in will have a constructor with two arguments: `pluginID` (assigned by emuStudio), and a context
      pool, which will be described later, in another type of plug-ins.


