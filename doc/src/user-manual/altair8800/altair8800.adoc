= Emulator of MITS Altair8800
(c) Copyright 2006-2016, Peter Jakubƒço
Version 0.39
:toc:
:numbered:

[[XI]]
== Introduction

Computer MITS Altair 8800 was named after a planet in one of the first episodes of Star Trek series. Having Intel 8080
CPU inside, with 256 bytes of memory, no display and keyboard is this computer, when comparing to the present era,
absolutely ridiculous. His author, Ed Roberts, called the invention "personal computer", which is now very common term.
As Wikipedia states:

[quote, Wikipedia, Altair 8800]
The Altair is widely recognized as the spark that ignited the microcomputer revolution.

image::altair8800/images/altair8800.png[MITS Altair8800 with LSI ADM-3A terminal and floppy drive]

Altair 8800 is one of the oldest commercially available computers overall. Ed Roberts (founder and CEO of MITS
corporation) was selling these machines by mail directly from the factory.

Various enthusiasts understood the power of Altair and started to develop software and hardware for the computer. Those
people saw a freedom in Altair - some kind of a release from batch tasks ran on mainframe systems, maintained by elite.
The phenomenon of a computer which could be put on the kitchen table allowed to make enormous money by two smart
university students. In 1975, Paul Allen and Bill Gates wrote a trimmed version of BASIC programming language, called
Altair BASIC, which pushed them directly to foundation of Microsoft corporation.

Basic configuration of MITS Altair 8800 was:

[width="50%"]
|======================================================================================================================
|Processor       | Intel 8080 or 8080a
|Speed           | 2 MHz
|RAM             | from 256 bytes to 64 kB
|ROM             | optional; usually EPROM Intel 1702 with 256 bytes. footnote:[They were used for various bootloaders]
|Storage         | optional; paper tapes, cassette tapes or 5.25" or 8" floppy disks (MITS 88-DISK)
|Extensions      | at first 16 slots, later 18 slots
|Bus             | famous S-100
|Video           | none
|I/O             | optional; parallel or serial board (MITS 88-SIO)
|OS capabilities | MITS DOS, CP/M, Altair Disk BASIC
|======================================================================================================================

[[XA]]
== Altair8800 for emuStudio

In emuStudio, there exist two variants of the computer. These variants varies only with the used CPU. There is available
either Intel 8080 emulator, or Zilog Z80 emulator. Lots of behavior and some devices was inspired by
http://simh.trailing-edge.com/[simh] emulator.

Abstract schema for emuStudio (Intel 8080):

image::altair8800/images/altairscheme.png[Abstract schema of MITS Altair8800 (with Intel 8080)]

Abstract schema for emuStudio (Zilog Z80):

image::altair8800/images/altairz80.png[Abstract schema of MITS Altair8800 (with Zilog Z80)]

The following plug-ins are used in the schemas. Each plug-in is described in further sections.

- Compiler: https://github.com/vbmacher/emuStudio/tree/branch-0_39/plugins/compilers/as-8080[as-8080]
- Compiler: https://github.com/vbmacher/emuStudio/tree/branch-0_39/plugins/compilers/as-z80[as-z80]
- Operating memory (RAM): https://github.com/vbmacher/emuStudio/tree/branch-0_39/plugins/mem/standard-mem[standard-mem]
- CPU: https://github.com/vbmacher/emuStudio/tree/branch-0_39/plugins/cpu/8080-cpu[8080-cpu]
- Another CPU: https://github.com/vbmacher/emuStudio/tree/branch-0_39/plugins/cpu/z80-cpu[z80-cpu]
- Device: https://github.com/vbmacher/emuStudio/tree/branch-0_39/plugins/devices/88-sio[88-sio]
- Device: https://github.com/vbmacher/emuStudio/tree/branch-0_39/plugins/devices/88-disk[88-disk]
- Device: https://github.com/vbmacher/emuStudio/tree/branch-0_39/plugins/devices/simhPseudo-z80[simhPseudo-z80]
- Device: https://github.com/vbmacher/emuStudio/tree/branch-0_39/plugins/devices/adm3A-terminal[adm3A-terminal]

== Assembler `as-8080`

Assembler for Intel 8080 CPU in emuStudio is very similar to
http://altairclone.com/downloads/manuals/8080%20Programmers%20Manual.pdf[Intel assembler], but has some little
differences. Features include:

- full instructions support
- macro support (unlimited nesting)
- include other files support
- data definition
- relative addressing using labels
- literals and expressions in various radixes (bin, dec, hex, oct)
- output is in Intel HEX format

== Assembler `as-z80`

Assembler for Zilog Z80 CPU. The assembler syntax is inspired by `as-8080` compiler, and by instruction set described
http://www.z80.info/zip/z80cpu_um.pdf[here]. The assembler supports the following features:

- full instructions support
- macro support (unlimited nesting)
- include other files support
- conditional assembly
- data definition
- relative addressing using labels
- literals and expressions in various radixes (bin, dec, hex, oct)
- output is in Intel HEX format only

== CPU: Intel 8080 emulator

TODO

== CPU: Zilog Z80 emulator

TODO

== Operating memory `standard-mem`

This plug-in fulfills requirements as RAM and ROM for real 8-bit computers emulation. Features:

- single cell is 1 byte wide
- memory size can be set up manually, by fefault it is 64KB
- managing ROM ranges
- loading binary memory images
- loading files in Intel HEX format
- possibility to save images for automatic loading at startup
- intuitive and useful GUI

[[XASMEML]]
=== Loading image files

[[XASMEMM]]
=== Manipulation with cells

[[XASMEMR]]
=== ROM areas

[[XASMEMB]]
=== Bank switching

== Disk controller `88-disk`

Altair Disk offered the advantage of fixed memory including relatively fast access to data. Data were transferred with
speed 250 Kb/s (The plug-in does not emulate this). Disk was connected with disk controller (or board), and the data
were transferred in serial fashion, bit after bit.

Disk controller, on the other hand communicated with CPU. It transformed these serial data into 8-bit words which were
stored/read by CPU into/from operating memory.

MITS 88-DISK offered to connect up to 16 disk devices (one can be seen in the front image in the Introduction section).

NOTE: Original manual can be downloaded at
      http://www.virtualaltair.com/virtualaltair.com/PDF/88dsk%20manual%20v2.pdf[this link].

=== Features

The plug-in emulates basic functionality of the whole disk system for Altair 8800 computer. It is not only disk
controller, but also the disk drive.

The features include:

- allows to mount up to 16 disk images
- CPU ports can be set manually
- interrupts are not implemented
- images can be saved for automatic mount at startup
- GUI

[[XDM]]
=== Mounting disk images

In order to mount DISK images to the device, please go to the Settings window footnoteref:[peripheral,"peripheral devices"
window in the Emulator panel in emuStudio]:

image::altair8800/images/88-disk-01.png[Settings window of 88-DISK]

- *A*: Select drive (A - P)
- *B*: Choosing the image file
- *C*: Set sectors count and sector length for the current drive footnote:[Be cautious with the settings. Incorrect
       values can result in disk image file damage. Default values are used for classic Altair8800 image files used by
       simh].
- *D*: Set default values for sector count and sector length for the current drive.

- *E*: Mount/unmount the image file onto/from the selected drive.
       Mount operation: If there is any disk mounted already, the new image will be re-mounted.
- *F*: Check box for saving the settings into the computer configuration file. If checked, the settings will be
       loaded after start.

=== CPU Ports settings

MITS 88-DISK board communicates with CPU using its ports. There are three ports overall, each for different function.
For more information, see section <<XDP,Programming>>. By default, the ports used by 88-DISK are:

- port 1: 0x08
- port 2: 0x09
- port 3: 0x0A

These numbers can be changed in the Settings window, tab "CPU Ports":

image::altair8800/images/88-disk-02.png[Setting CPU ports]

=== Advanced: Settings in configuration file

Configuration file of virtual computers contain also settings of all the used plug-ins, including devices. Please
read the section "Accessing settings of plug-ins" in the user documentation of Main module to see how the settings can
be accessed.

The following table shows all the possible settings of MITS 88-DISK plug-in:

.Settings of MITS 88-DISK
[width="60%",frame="topbot",options="header,footer"]
|==========================================================================================
|Name           | Default value | Valid values         | Description
|`port1CPU`     | 0x08          | > 0 and < 256        | Number of Port 1
|`port2CPU`     | 0x09          | > 0 and < 256        | Number of Port 2
|`port3CPU`     | 0x0A          | > 0 and < 256        | Number of Port 3
|`sectorsCount` | 32            | > 0                  | Count of sectors in a disk image
|`sectorLength` | 137           | > 0                  | Size of one sector in bytes
|`image0`       | N/A           | Path to existing file| File name to mount on disk A (0)
| ...           | ...           | ...                  | ...
|`image15`      | N/A           | Path to existing file| File name to mount on disk P (15)
|==========================================================================================

[[XDP]]
=== Advanced: Programming

Data are written onto or read from disk in a serial fashion. The position in the floppy disk is uniquely set by the
track number, sector number and the offset in the sector. It is rudimentary to know how many tracks are available,
so as how many sectors per track and the sector size.

In Altair8800, drive `Pertec FD400` used 8" diskettes. Each had 77 tracks. The track had 32 sectors with 137 bytes long.
The capacity was therefore `77 * 32 * 137 = 337568 B = 330 kB`. Software used less capacity, because 9 bytes from
each sector were used for the integrity checksum.

==== Setting the position

Track number and sector number can be set only incrementally, not directly. Setting the offset within the sector is
more challenging.

After track and sector were set, programmer must "poll" the status port which tells him when the
disk position is set to the beginning of the sector. Then, programmer must read data until he gets to the position
where he wanted.

==== CPU Ports

The controller communicates with CPU using three I/O ports at addresses (by default) 0x08, 0x09 and 0x0A. The following
table shows the CPU ports and how they are used.

.Summary of CPU ports usage
[width="60%",frame="topbot",options="header,footer"]
|================================================================
|Port     | Address | Input                      | Output
|1        | 0x08    | Disk and controller status | Select disk
|2        | 0x09    | Get number of sector       | Disk settings
|3        | 0x0A    | Read data                  | Write data
|================================================================

Now, detailed description of the ports follow. Bits are ordered in a byte as follows:

    D7 D6 D5 D4 D3 D2 D1 D0

where `D7` is the most significant bit, and `D0` the least significant bit.

===== Port 1 (default address: 0x08)

*WRITE*:

Selects and enables one of 16 disk devices. By selecting a drive, all further operations
will be performed on that drive. If the disk has not mounted any disk image, all further operations will be ignored.
The previously selected device will be disabled.

- `D7`         : if the value is 1, disable the drive. If the value is 0, select and enable the drive.
- `D6 D5 D4`   : unused bits
- `D3 D2 D1 D0`: index of the drive to be selected. From 0-15.

*READ*:

Read disk status of the selected drive.

- `D7` : _New read data available_. Indicates if there is at least 1 byte available for reading from Port 3 (value=0).
          It will be reset after data are read (value=1). If the value is 1, data read from Port 3 will be invalid or
          no new data is available.
- `D6` : _Track 0_. Indicates if the head is positioned at track 0 (value=0).
- `D5` : _Interrupt Enabled_. Indicates if interrupts are used (value=0). The plug-in does not support interrupts,
         therefore the value will be always 1.
- `D4 D3` : Unused bits; they are always 0.
- `D2` : _Head Status_. Indicates the correctness of the head setting. If the value is 0, reading sector number from Port 2
         will be valid.
- `D1` : _Move head_. Indicates if the movement of the disk head is allowed. If the value is 1, all track number changes
         will be ignored.
- `D0` : _Enter new write data_. Indicates if the device is ready for writing data. If the value is 1, all written
         data will be ignored.

Initial values of the bits are: `11100111`.

===== Port 2 (default address: 0x09)

*WRITE*:

Control the disk head, and other settings if a disk drive is selected.

- `D7` : _Write Enable_. Initializes write sequence (enables writing to the disk; value=1). The plug-in sets the sector
         number to 0 and also value 0 to bit `D0` of Port 1 (_Enter new write data_) footnote:[According to manual
         the write sequence holds only for short time, maximally until the end of sector is reached. The plug-in does
         not limit the sequence period, it is deactivated only when the end of the sector is reached. In addition each
         first byte and the last byte of a sector should have set its MSB (7th bit) to 1. It was called the "sync bit"
         for easier identification of start or end of a sector. However, the plug-in does not require it.].
- `D6` : _Head Current Switch_. On real disks the bit should be set to 1 when a program is writting data to tracks
         from 43-76. The plug-in the bit is ignored.
- `D5` : _Interrupt Disable_. Setting is ignored sicne plug-in does not support interrupts.
- `D4` : _Interrupt Enable_. Setting is ignored sicne plug-in does not support interrupts.
- `D3` : _Head unload_. Removes head from the disk surface. Reading sector number will now become invalid. In addition,
         value of bit `D7` from Port 1 (_New read data available_) become 1 (no new data).
- `D2` : _Head load_. Sets the disk head onto disk surface. Reading sector number now becomes valid. If additionally
         the bit `D7` from Port 1 (_New data available_) is set, it is possible to read data from the disk.
- `D1` : _Step Out_. Move the disk head back by 1 track (the track number is decremented). It is required to check
         bit `D1` of Port 1 (_Move head_) to have value 0.
- `D0` : _Step In_. Move the disk head ahead by 1 track (the track number is incremented). It is required to check
         bit `D1` of Port 1 (_Move head_) to have value 0.

*READ*:

Reads the number of the sector. The value can be read only if a disk drive is selected and the disk head is positioned
at the disk surface (by setting the bit `D2`).

- `D7 D6` : Unused bits; they are always 1.
- `D5 D4 D3 D2 D1`: Number of the sector, counted from 0.
- `D0` : _Sector True_. If the value is 0, the offset in sector is 0 footnote:[According to manual, the bit is set for
         maximum 30 microseconds. Programs could detect the bit set and quickly start writing data until the _Sector true_
         came back again. It could be made in time easily, because CPU was much faster than disk itself.
         Plug-in does not limit the period. The value is 0 practically all the time, until first byte is written.].

===== Port 3 (default address: 0x0A)

*WRITE*:

Write a byte to disk. In order to perform valid write, the _Write Enable_ `D7` bit of Port 2 must be set to 1. Before data
are written to disk, it is required to check bit `D0` from Port 1 (_Enter new write data_).

*READ*:

Read a byte from disk. In order to perform valid read, the _Head load_ `D2` bit of Port 2 must be set to 1. Only if bit
`D7` from Port 1 (_New read data available_) is set to 0, the read data are valid.

==== Program example

In this section, an example is presented showing how to read/write data from/to the floppy disk. At first, it writes
one byte (letter `A` with ASCII value 65) to track 1, sector 18 and offset 20. Then, it reads the byte to operating
memory at address 0x200.

The program uses 3 procedures (in assembler for Intel 8080) for setting the disk position (`ltrack` for loading the
track number, `lsector` for loading the sector number, and `loffset` for loading the offset within the sector) and two
more for data reading (`read`) and writing (`write`).

.Example program for writing/reading using MITS 88-DISK
-----------------------------------------------------
disk0  equ 0    ; disk number
track  equ 1    ; track number
sector equ 18   ; sector number
offset equ 20   ; offset within the sector
data   equ 'A'  ; data for writing

dcx sp          ; set stack register to 0xFFFF

mvi a, disk0    ; select disk
out 08h

call ltrack     ; set track number

call we         ; set 'write enable' sequence
call lsector    ; set sector number
call loffset    ; set sector offset
call write      ; write data

call lsector    ; set sector number (for clearing the offset)
call loffset    ; set sector offset
call read       ; read data

lxi h, readdata ; load address for reading the data
mov m, a        ; move the data there

hlt             ; end

ltrack0:        ; the procedure will set track number to 0
in 08h          ; read disk status
ani 1000000b    ; track 0 ?
rz              ; yes, return
mvi a, 1000b    ; head unload
out 09h
call movetrk    ; wait until the disk head can be moved
mvi a, 10b      ; step out, decrement track number
out 08h
jmp ltrack0

ltrack:         ; procedure sets a track number
call ltrack0    ; at first, set track number to 0
mvi b, track+1  ; b = track + 1
stepin:         ; stepin: {
dcr b           ;   b--;
rz              ;   if (b == 0) return;
call movetrk    ;   wait until the disk head can be moved
mvi a, 1        ;   step in, increment track number
out 09h
jmp stepin      ;   goto stepin;
                ; }

movetrk:        ; procedure waits until the disk head can be moved
in 08h          ; read disk status
ani 10b         ; can the disk head be moved?
jnz movetrk     ; nope, try again...
ret             ; yes, return

lsector:        ; procedure sets a sector number
mvi a, 100b     ; head load
out 09h
waits:
in 09h          ; read sector number
ani 3Fh         ; clear unused bits
rrc
cpi sector      ; is the number what is requested?
jnz waits       ; nope, try again
ret             ; yes, return

loffset:        ; procedure sets a sector offset
mvi b, offset+1 ; b = offset + 1
stepoff:        ; stepoff: {
dcr b           ;   b--;
rz              ;   if (b == 0) return;
call read       ;   read data; the offset is incremented
jmp stepoff     ;   goto stepoff;
                ; }

read:           ; procedure reads data from the disk
in 08h          ; read disk status
ani 100b        ; check if the disk head is loaded on the disk surface
rnz             ; if not, return
waitr:
in 08h          ; read disk status
ani 10000000b   ; New read data available ?
jnz waitr       ; nope, try again...
in 0Ah          ; yes, read data
ret             ; return

we:             ; procedure enables 'write enable' sequence
mvi a, 10000000b ; write enable
out 09h
ret

write:          ; procedure writes data to the disk
in 08h          ; read disk status
ani 100b        ; check if the disk head is loaded on the disk surface
rnz             ; if not, return
waitw:
in 08h          ; read disk status
ani 1           ; enter new write data ?
jnz waitw       ; nope, try again...
mvi a, data     ; yes, write data
out 0Ah
ret

org 200h
readdata: db 0
-----------------------------------------------------

== Serial board `88-sio`

Altair 8800 computer was equipped with serial board called 88-SIO. It was a device which allowed connecting other
devices using RS-232 interface. From one side it was attached to CPU on two ports (0x10 and 0x11). The other side
was ended with one or two physical ports (allowing to connect one or two devices). Real board supported both hardware
and software interrupts.

The following image shows MITS 88-SIO-2 board.

image::altair8800/images/88-sio-2.png[Serial board MITS 88-SIO-2]

NOTE: Original manual of MITS 88-SIO serial board can be downloaded at
      http://maben.homeip.net/static/s100/altair/cards/Altair%2088-SIO%20serial%20IO.pdf[this link].

=== Features

The plug-in emulates only basic functionality of the board. It has the following features:

- allows to connect one device only
- CPU ports can be set manually
- interrupts are not implemented
- setting of transfer speed, parity, number of stop bits is not supported
- GUI

=== CPU Ports settings

MITS 88-SIO board is attached to CPU using two ports. By allowing settings of the port numbers the board can be used
in other computers, too. By default, the ports used by 88-SIO are:

- port 1: 0x08
- port 2: 0x09

These numbers can be changed in the Settings window, tab "CPU Ports":

image::altair8800/images/88-sio-ports.png[Setting CPU ports]

=== Connecting devices

MITS 88-SIO board as emuStudio plug-in is a device which does nothing really useful. It just listens (and understands)
commands coming from CPU through the I/O ports. The command is either a request for reading or request for writing to
the attached device.

NOTE: Theoretically any device which supports the basic I/O (reading/writing), can be attached to the board. More about
      plug-in internals can be found in programmer's manual of emuStudio, which is not part of the user documentation.

Usually, attached devices were:

- serial terminal
- line printer
- paper tape reader/punch

In current implementation of Altair 8800 emulator, the only suitable device which can be attached to the board is
terminal ADM-3A from Lear Siegler, Inc and which is described in its own section.

=== Advanced: Settings in configuration file

Configuration file of virtual computers contain also settings of all the used plug-ins, including devices. Please
read the section "Accessing settings of plug-ins" in the user documentation of Main module to see how the settings can
be accessed.

The following table shows all the possible settings of MITS 88-SIO plug-in:

.Settings of MITS 88-SIO
[width="60%",frame="topbot",options="header,footer"]
|==========================================================================================
|Name               | Default value | Valid values         | Description
|`statusPortNumber` | 0x10          | > 0 and < 256        | Number of Status Port
|`dataPortNumber`   | 0x11          | > 0 and < 256        | Number of Data Port
|==========================================================================================

[[XSP]]
=== Advanced: Programming

In order to show something useful, let's assume that a terminal LSI ADM-3A is attached to the board.
Remember, the board only mediates the communication, it does not interpret any of the sent/received characters.

==== CPU Ports

The whole communication between the board (and attached device) and CPU is controlled by programming the two ports:
Status port and Data port. The following table shows the ports and how they are used.

.Summary of CPU ports usage
[width="60%",frame="topbot",options="header,footer"]
|===========================================================================
|Port     | Address | Input                      | Output
|1        | 0x10    | Read board status          | Only 'empties' buffer
|2        | 0x11    | Read data                  | Write data
|===========================================================================

Now, detailed description of the ports follow. Bits are ordered in a byte as follows:

    D7 D6 D5 D4 D3 D2 D1 D0

where `D7` is the most significant bit, and `D0` the least significant bit.

==== Port 1 (default address: 0x10)

*WRITE*:

Controls input/output interrupts enable. If both interrupts are set to be enabled, it only empties transmitter buffer
in the device, which was a post-step after interrupts being enabled. However, the plug-in does not implement interrupts
support.

- `D7 D6 D5 D4 D3 D2` : unused bits
- `D1 D0`             : Value `03` will cause to empty transmitter buffer. Other values are ignored.

*READ*:

Read status of the device.

- `D7` : _Output device ready_. Value 0 means that a ready pulse was sent from device. Value 1 means the device is not
         ready.
- `D6` : Not used.
- `D5` : _Data available_. Value 1 means that a word of data is in the buffer on the I/O board.
- `D4` : _Data overflow_. Value 1 means a new word of data has been received before the previous word was inputted to
         the accumulator. In emuStudio, this never happens.
- `D3` : _Framing error_. Value 1 means that data bit has no valid stop bit. In emuStudio, this never happens.
- `D2` : _Parity error_. Value 1 means that received parity does not agree with selected parity. In emuStudio, this
         never happens.
- `D1` : _Transmitter buffer empty_. Value 1 means that the previous data word has been transmitted and a new data
         word may be outputted. Practically it means CPU can read data from the data port.
- `D0` : _Input device ready_. Value 1 means a ready pulse has been sent from the device. Practically it means that
         CPU can write data to the data port.

=== Port 2 (default address: 0x11)

*WRITE*:

Write data to the attached device.

*READ*:

Read data from the attached device.

==== Program example

In this section it will be shown a small "How to" program terminal using 88-SIO ports.

===== Print a character on screen

In emuStudio, it is enough to write data to Port 2, e.g.:

.Example program for writing character on terminal
--------------------------------------------------
mvi a, 'H'
out 11h
mvi a, 'i'
out 11h
--------------------------------------------------

===== Print a string on screen

For writing strings, it is more practical to have a procedure.

.Example program for writing text on terminal
---------------------------------------------
lxi h, text  ; load address of 'text' label to HL
call print   ; print text
hlt          ; halt CPU

text: db 'Hello, world!',0

; Procedure for printing text to terminal.
; Input: pair HL must contain the address of the ASCIIZ string
print:
    mov a, m  ; load character from HL
    inx h     ; increment HL
    cpi 0     ; is the character = 0?
    rz        ; yes; quit
    out 11h   ; otherwise; show it
    jmp print ; and repeat from the beginning
---------------------------------------------

===== Reading character from keyboard

For reading a character, it is required to read the Port 1 until the character is not ready. Then we can read it from
Port 2.

.Example procedure for reading a character from terminal
--------------------------------------------------------
; Procedure will read a single character from terminal
; Input: none
; Output: register A will contain the character.
getchar:
    in 10h     ; read Port 1
    ani 1      ; is data ready ?
    jz getchar ; not; try again
    in 11h     ; yes; read it (into A register)
    ret
--------------------------------------------------------

===== Reading text from keyboard

Now follows an example, which will read a whole line of characters into memory starting at address in `DE` pair. The
procedure will interpret some control keys, like: backspace and ENTER keys.

.Example program for reading text from terminal
------------------------------------------------
lxi h, text        ; load address of 'text' label to HL
xchg               ; DE <-> HL
call getline       ; read line from the keyboard into DE

lxi h, text        ; load 'text' address again
call print         ; print the text on screen

hlt                ; halt CPU

text: ds 30        ; here will be stored the read text

;Procedure for reading a text from keyboard.
;Input: DE = address, where the text should be put after reading
;       C  = is used internally
getline:
    mvi c, 0       ; register C will be used as a counter of
                   ; read characters
next_char:
    in 10h         ; read Port 1: status
    ani 1          ; is the char ready for reading?
    jz next_char   ; not; try again
    in 11h         ; yes; read it to A register

    ; now ENTER and Backspace will be interpreted
    cpi 13         ; ENTER?
    jz getline_ret ; yes; it means end of input
    cpi 8          ; Backspace ?
    jnz save_char  ; if not; store the character

    ; Backspace interpretation
    mov a, c       ; A <- number of read characters
    cpi 0          ; are we at the beginning?
    jz next_char   ; yes; ignore the backspace

    dcx d          ; not; decrement DE
    dcr c          ; decrement count of read characters
    mvi a,8        ; "show" the backspace (terminal will
                   ; interpret this by moving the cursor
                   ; to the left by 1 char)
    out 11h
    mvi a, 32      ; "clear" the current character on screen
                   ; by a space character (ASCII code 32)
    out 11h

    mvi a,8        ; and move the cursor back again
    out 11h
    jmp next_char  ; jump to next char

save_char:         ; stores a character into memory at DE
    out 11h        ; show the character in A register
    stax d         ; store it at address DE
    inx d          ; increment DE
    inr c          ; increment number of read characters
    jmp next_char  ; jump to next char

getline_ret:       ; end of input
                   ; ENTER will be stored as CRLF
    mvi a,13       ; CR (Carriage Return)
    stax d         ; store the char
    inx d          ; increment DE
    mvi a, 10      ; LF (Line Feed)
    stax d         ; store the char
    inx d          ; increment DE
    mvi a, 0       ; char 0 (End-Of-Input)
    stax d         ; store the char
    ret            ; return
------------------------------------------------

== Terminal `adm3a-terminal`

Emulation of famous terminal from Lear Siegler, Inc. - ADM-3A. It had a nick name 'Dumb Terminal'. In the time (1974),
due to its cheapness and speed capabilities required in that time, it became de facto standard in the industry.
Often it was used in connection with MITS Altair 8800 computer, so the decision of which terminal to emulate was clear.

NOTE: The maintenance manual can be downloaded at
      http://www.mirrorservice.org/sites/www.bitsavers.org/pdf/learSiegler/ADM3A_Maint.pdf[this link], operator's manual
      http://maben.homeip.net/static/s100/learSiegler/terminal/Lear%20Siegler%20ADM3A%20operators%20manual.pdf[here].

=== Display

The terminal could display 128 ASCII characters (upper-case and lower-case letters, punctuation and numbers). The
original ADM-3 could display only 64 (only capital-letters and some other). For saving very expensive RAM the terminal
offered size 12 rows x 80 columns, with optional extension to 24 rows x 80 columns. The size used in the emulator is
hardcoded to 80 columns x 24 rows.

Besides, the emulator uses custom font colored green, with anti-aliasing support and double-buffering.

=== Keyboard

The terminal could generate always 128 ASCII characters (upper-case, lower-case, punctuation and numbers). Besides,
it could generate special control characters which had effect on the current cursor position and were not sent to
CPU.

The emulator allows to generate almost anything what your host keyboard can give. It is only up to font which characters
it can display. The font cannot display any special non-US characters used in various languages. Just classic ASCII.

Besides, the terminal can capture control codes (holding `CTRL` plus some key), and special control codes (`ESC + '='`
plus some key). The following subsection lists all possible control and special control key combinations.

[[XCC]]
==== Control codes

The following table shows control codes (`CTRL` plus some key combinations). The table can be found in original manuals.
The emulator is following it.

.Control codes
[width="60%",frame="topbot",options="header,footer"]
|==========================================================================================
| Code     | ASCII mnemonic | Function in ADM-3A
|`CTRL+@`  | `NUL`   |
|`CTRL+A`  | `SOH`   |
|`CTRL+B`  | `STX`   |
|`CTRL+C`  | `ETX`   |
|`CTRL+D`  | `EOT`   |
|`CTRL+E`  | `ENQ`   | Initiates ID message with automatic "Answer Back" option. footnoteref:[control,"In the original
                       ADM-3A device, these codes were executable only from computer."]
|`CTRL+F`  | `ACK`   |
|`CTRL+G`  | `BEL`   | Sounds audible beep in ADM-3A (not in emulator yet :( )
|`CTRL+H`  | `BS`    | Backspace
|`CTRL+I`  | `HT`    |
|`CTRL+J`  | `LF`    | Line feed
|`CTRL+K`  | `VT`    | Upline
|`CTRL+L`  | `FF`    | Forward space
|`CTRL+M`  | `CR`    | Return
|`CTRL+N`  | `SO`    | Unlock keyboard footnoteref:[control]
|`CTRL+O`  | `SI`    | Lock keyboard footnoteref:[control]
|`CTRL+P`  | `OLE`   |
|`CTRL+Q`  | `DCI`   |
|`CTRL+R`  | `DC2`   |
|`CTRL+S`  | `DC3`   |
|`CTRL+T`  | `DC4`   |
|`CTRL+U`  | `NAK`   |
|`CTRL+V`  | `SYN`   |
|`CTRL+W`  | `ETB`   |
|`CTRL+X`  | `CAN`   |
|`CTRL+Y`  | `EM`    |
|`CTRL+Z`  | `SUB`   | Clear screen
|`CTRL+[`  | `ESC`   | Initiate load cursor
|`CTRL+x`  | `FS`    |
|`CTRL+]`  | `GS`    |
|`CTRL+^`  | `RS`    | Home cursor
|==========================================================================================

==== Absolute cursor position from the keyboard

The terminal also allowed to set the absolute cursor position, when in "Cursor control Mode". The ADM-3A emulator
does not have such mode, but `ESC+'=' X Y` combinations allows to set the cursor position. As you could see in
the <<XCC>> section, pressing the `ESC` "Initiates load cursor" operation. If the user then presses `=` key, then
the terminal takes next 2 keystrokes, and translates them into `X` and `Y` coordinates for the new position of the
cursor. The following table shows the key-to-coordinate translation table.

.Translation of keystrokes to cursor coordinates
[width="60%",frame="topbot",options="header,footer"]
|===============
| Key  | Number
|`' '` | `0`
|`!`   | `1`
|`"`   | `2`
|`#`   | `3`
|`$`   | `4`
|`%`   | `5`
|`&`   | `6`
|`'`   | `7`
|`(`   | `8`
|`)`   | `9`
|`*`   | `10`
|`+`   | `11`
|`,`   | `12`
|`-`   | `13`
|`.`   | `14`
|`/`   | `15`
|`0`   | `16`
|`1`   | `17`
|`2`   | `18`
|`3`   | `19`
|`4`   | `20`
|`5`   | `21`
|`6`   | `22`
|`7`   | `23`
|`8`   | `24`
|`9`   | `25`
|`:`   | `26`
|`;`   | `27`
|`<`   | `28`
|`=`   | `29`
|`>`   | `30`
|`?`   | `31`
|`@`   | `32`
|`A`   | `33`
|`B`   | `34`
|`C`   | `35`
|`D`   | `36`
|`E`   | `37`
|`F`   | `38`
|`G`   | `39`
|`H`   | `40`
|`I`   | `41`
|`J`   | `42`
|`K`   | `43`
|`L`   | `44`
|`M`   | `45`
|`N`   | `46`
|`O`   | `47`
|`P`   | `48`
|`Q`   | `49`
|`R`   | `50`
|`S`   | `51`
|`T`   | `52`
|`U`   | `53`
|`V`   | `54`
|`W`   | `55`
|`X`   | `56`
|`Y`   | `57`
|`Z`   | `58`
|`[`   | `59`
|`\`   | `60`
|`]`   | `61`
|`^`   | `62`
|`_`   | `63`
|```   | `64`
|`a`   | `65`
|`b`   | `66`
|`c`   | `67`
|`d`   | `68`
|`e`   | `69`
|`f`   | `70`
|`g`   | `71`
|`h`   | `72`
|`i`   | `73`
|`j`   | `74`
|`k`   | `75`
|`l`   | `76`
|`m`   | `77`
|`n`   | `78`
|`o`   | `79`
|===============

=== ADM-3A Settings

It is possible to configure the terminal either from GUI or manually modifying configuration settings. In the case
of manual file modification, emuStudio must be restarted (for more information, see section <<XADSITCDF>>).

The "settings" window footnoteref:[peripheral] is
shown in the following image:

image::altair8800/images/adm3a-settings.png[Settings window of ADM-3A terminal]

- *A*: File for reading input (when redirected)
- *B*: File for writing output (when redirected)
- *C*: In automatic mode, how long the terminal should wait until it reads next input character from the file
       (in milliseconds)
- *D*: Whether every keystroke will also cause to display it. Programs don't always "echo" the characters back
       to the screen.
- *E*: Whether terminal GUI should be always-on-top of other windows
- *F*: Whether the display should use anti-aliasing.
- *G*: Clears the screen.
- *H*: Rolls the screen down by 1 line
- *I*: If checked, then by pressing OK the settings will be saved to the configuration file. If not, they will be not
       saved. In any case, the effect of the settings will be visible immediately.

NOTE: The terminal behaves differently when emuStudio is run in automatic (no GUI) mode. In that moment, input is
      redirected to be read from a file, and also output is redirected to be written to another file. The file names are
      configurable in the computer config file. Using redirection in GUI mode is currently not possible.

[[XADSITCDF]]
==== Advanced: Settings in the configuration file

Configuration file of virtual computers contain also settings of all the used plug-ins, including devices. Please
read the section "Accessing settings of plug-ins" in the user documentation of Main module to see how the settings can
be accessed.

The following table shows all the possible settings of ADM-3A plug-in:

.Settings of LSI ADM-3A
[width="60%",frame="topbot",options="header,footer"]
|=====================================================================================================
|Name              | Default value        | Valid values          | Description
|`inputFileName`   | `terminalADM-3A.in`  | Path to existing file | File for reading input (when redirected)
|`outputFileName`  | `terminalADM-3A.out` | Path to existing file | File for writing output (when redirected)
|`inputReadDelay`  | 0                    | > 0                   | How long the terminal should wait
                                                                    until it reads next input character from the file
                                                                    (in milliseconds)
|`alwaysOnTop`     | false                | true / false          | Whether terminal GUI should be always-on-top of other
                                                                    windows
|`antiAliasing`    | false                | true / false          | Whether the display should use anti-aliasing.
|`halfDuplex`      | false                | true / false          | Whether every keystroke will also cause to display
                                                                    it.
|=====================================================================================================


== Virtual device `simhPseudo-z80`

Virtual device partially reimplemented from http://simh.trailing-edge.com/[simh] emulator. This device is used
mainly for communication between CP/M 3 operating system for `simh` and emuStudio. Most of the original functionality
is not implemented, but it is crucial for support of memory bank-switching.

== Original software, operating systems

Since Altair8800 virtual computer emulates a real machine, it's possible to use real software written for the computer.
As was mentioned in <<XA,Altair for emuStudio>> section, several operating systems and programs can be run on Altair.
There are many disk and memory images of those systems available online, but only some were tested and proved to work.

Most of the disk images were borrowed from great http://simh.trailing-edge.com/[simh] emulator.
It's obvious that some images were modified for simh. It's not really obvious if original images would actually work
at all.

Tested and fully-functional images were:

- Operating system CP/M v2.2 and 3
- Altair DOS v1.0
- BASIC programming language in various versions

The following subsections describe in short how to boot those systems, along with screen-shots how it looks.

[[XBBR]]
=== Boot ROM

Booting operating systems on Altair requires special ROM image to be <<XASMEML,loaded in operating memory>>
footnote:[The purpose of a boot ROM is to load specific block of data from a device and then run it as if it was code.
The code block is often called 'boot loader'. It is very small program which just loads either the whole or part of the
operating system into memory and then jumps to it.].

Originally, more boot ROMs existed. Different boot ROMs were used to load the code from different devices.
In current implementation of emuStudio, there is only one boot ROM supported - so called 'disk boot loader' (or DBL),
which loads operating system from MITS 88-DISK (through CPU ports).

The boot loader is already available in a file `boot.bin`. You can find it at the
http://emustudio.sourceforge.net/downloads.html[download page].

The boot ROM must be loaded into memory at address `0xFF00` (hexadecimal). It is safe to jump to this address manually
when operating system image file is mounted.

NOTE: All subsequent sections assume that the boot loader has been loaded in the operating memory.

=== CP/M 2.2

During Altair8800 computer era, many operating systems, applications and programming languages have been developed.
On of the most known operating systems is CP/M. It was written by Gary Kildall from Digital Research, Inc. At first
it was mono-tasking and single-user operating system which didn't need more than 64kB of memory. Subsequent versions
added multi-user variants and they were ported to 16-bit processors.

The combination of CP/M and computers with S-100 bus footnote:[8-bit computers sharing some similarities with Altair 8800]
was big "industry standard", widely spread in 70's up to 80's years of twentieth century. The operating system took
the burden of programming abilities from user, and this was one of the reasons why the demand for hardware and software
was rapidly increased.

Tested image has name `altcpm.dsk`. It can be downloaded at http://schorn.ch/cpm/zip/altsw.zip[this link].

In order to run CP/M, please follow these steps:

1. <<XDM,Mount disk image>> `altcpm.dsk` to drive `A:` in MITS 88-DISK.
2. In emuStudio jump to location `0xFF00` footnoteref:[debugger,See "Debugger toolbar" in the user documentation of Main module]
3. Optionally, you can set CPU frequency to 2000 kHz, which was Intel 8080 original frequency.
4. Before starting emulation, show ADM-3A terminal, which can be found in "peripheral devices" window.
5. Run the emulation footnoteref:[debugger]

After these steps were completed, CP/M should start (an informational message appears) and command line prompt will
be displayed:

image::altair8800/images/cpm22.png[Operating system CP/M 2.2]

NOTE: Command `dir` is working, `ls` is better `dir`. More information about CP/M commands can be found at
      http://www.classiccmp.org/dunfield/r/cpm22.pdf[this link].

=== CP/M 3

Steps for running CP/M 3 operating systems are not that different from CP/M 2. The disk image file is called
`cpm3.dsk` and can be downloaded at http://schorn.ch/cpm/zip/cpm3.zip[this link]. CP/M 3 came with two versions:
banked and non-banked. The image is the banked version of CP/M. Also, `simh` authors provided custom BIOS and custom
boot loader.

NOTE: Manual of CP/M 3 can be found at http://www.cpm.z80.de/manuals/cpm3-usr.pdf[this link]. For more information
      about `simh` Altair8800 and CP/M 3, click http://simh.trailing-edge.com/pdf/altairz80_doc.pdf[here].

There are some requirements for the computer architecture, a bit different for CP/M 2.2.

==== CPU

It is recommended to use Z80 version of the computer as was presented in the section <<XA, Altair8800 for emuStudio>>.
CPU Intel 8080 will work for the operating system itself, but most provided applications require Z80.

==== Operating memory
Also, the operating memory needs to be set for memory banks footnote:[Please see section <<XASMEMB, Bank switching>>].
The following parameters were borrowed from `simh` and were tested:

- 8 memory banks
- common address `C000h`

==== Boot ROM

There exist specific version of boot loader (modified probably by `simh` authors) to load CP/M into banked memory.
It has name `mboot.bin` and you can find it at the http://emustudio.sourceforge.net/downloads.html[download page].
Before other steps, please <<XASMEML, load this image into operating memory>> at address 0xFF00 (hexadecimal).

==== Steps for booting CP/M 3

Specific steps how to boot CP/M 3 in emuStudio follow:

1. <<XDM,Mount disk image>> `cpm3.dsk` to drive `A:` in MITS 88-DISK.
2. In emuStudio jump to location `0xFF00` footnoteref:[debugger]
3. Optionally, you can set CPU frequency to 2500 kHz, which was Zilog Z80 original frequency.
4. Before starting emulation, show ADM-3A terminal, which can be found in "peripheral devices" window.
5. Run the emulation footnoteref:[debugger]

The following image shows the look right after the boot:

image::altair8800/images/cpm3.png[Operating system CP/M 3 (banked version)]

=== Altair DOS v1.0

TODO

=== BASIC

In this section will be presented how to boot MITS BASIC version 4.1. There is possible to boot also other versions,
but the principle is always the same.

As it is written in `simh` manual: MITS BASIC 4.1 was the commonly used software for serious users of the Altair
computer. It is a powerful (but slow) BASIC with some extended commands to allow it to access and manage the disk.
There was no operating system it ran under.

NOTE: After boot, you must mount the disk with `MOUNT 0`. Then, command `FILES` will show all files on the disk. In
      order to run a file, run command `RUN "file"`. Manual can be found at
      http://bitsavers.informatik.uni-stuttgart.de/pdf/mits/Altair_8800_BASIC_4.1_Reference_Jul77.pdf[this link].

It is assumed you have either `boot.bin` or `mboot.bin` mounted in the operating memory (see <<XBBR,Boot ROM>> for more
details).

Steps for booting BASIC follow:

1. <<XDM,Mount disk image>> `mbasic.dsk` to drive `A:` in MITS 88-DISK.
2. In emuStudio jump to location `0xFF00` footnoteref:[debugger]
3. Optionally, you can set CPU frequency to 2000 kHz, which was Intel 8080 original frequency.
4. Before starting emulation, show ADM-3A terminal, which can be found in "peripheral devices" window.
5. Run the emulation footnoteref:[debugger]

The following image shows the look right after the boot:

image::altair8800/images/mbasic.png[Altair 8800 Basic 4.1]
